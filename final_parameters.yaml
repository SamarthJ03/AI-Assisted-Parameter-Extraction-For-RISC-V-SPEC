# RISC-V Architectural Parameter Extraction - Final Results

LLMS_USED:
  - name: Qwen-2.5-14B-Instruct
    developer: Alibaba Cloud (Qwen Team)
    model_size: 14 Billion Parameters
    context_length: 128k Tokens
    hyperparameters: {temperature: 0.0, seed: 42, max_new_tokens: 1024}

  - name: Llama-3.1-8B-Instruct
    developer: Meta AI
    model_size: 8 Billion Parameters
    context_length: 128k Tokens
    hyperparameters: {temperature: 0.0, seed: 42, max_new_tokens: 1024}

RESULTS:
  Snippet1:
    text: >
      Privileged Spec 19.3.1: Caches organize copies of data into cache blocks, each of which 
      represents a contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations. 
      A cache block is identified by any of the physical addresses corresponding to the underlying 
      memory locations. The capacity and organization of a cache and the size of a cache block are 
      both implementation-specific, and the execution environment provides software a means to 
      discover information about the caches and cache blocks in a system. In the initial set of 
      CMO extensions, the size of a cache block shall be uniform throughout the system.
    status: "Success - High Consensus"
    parameters:
      - name: cache_capacity
        description: "The total capacity of the cache."
        type: integer
        constraints: implementation-specific
      - name: cache_organization
        description: "The organization structure of the cache (e.g., associativity)."
        type: structural
        constraints: implementation-specific
      - name: cache_block_size
        description: "The size of a cache block; must be a power-of-two."
        type: integer
        constraints: uniform throughout the system

  Snippet2:
    text: >
      Privileged Spec 2.1: "Conventional" R/W accessibility of CSRs according to address mapping.
      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up to 4,096 CSRs. 
      By convention, the upper 4 bits of the CSR address (csr[11:8]) are used to encode the read 
      and write accessibility of the CSRs according to privilege level as shown in Table 1. 
      The top two bits (csr[11:10]) indicate whether the register is read/write (00,01, or 10) 
      or read-only (11). The next two bits (csr[9:8]) encode the lowest privilege level that 
      can access the CSR.
    status: "Success - Filtered"
    note: "AI correctly identified text as fixed ISA mandates rather than implementation-defined parameters."
    parameters: []

VALIDATION:
  extension_target: "Zicntr and Zihpm Extensions (v2.0)"
  full_text_ref: >
    Zicntr" and "Zihpm" Extensions for Counters, Version 2.0
    RISC-V ISAs provide a set of up to thirty-two 64-bit performance counters and timers that are accessible via unprivileged XLEN-bit read-only CSR registers 0xC00–0xC1F (when XLEN=32, the upper 32 bits are accessed via CSR registers 0xC80–0xC9F). These counters are divided between the "Zicntr" and "Zihpm" extensions.

    "Zicntr" Extension for Base Counters and Timers
    The Zicntr standard extension comprises the first three of these counters (CYCLE, TIME, and INSTRET), which have dedicated functions (cycle count, real-time clock, and instructions retired, respectively). The Zicntr extension depends on the Zicsr extension.

    We recommend provision of these basic counters in implementations as they are essential for basic performance analysis, adaptive and dynamic optimization, and to allow an application to work with real-time streams. Additional counters in the separate Zihpm extension can help diagnose performance problems and these should be made accessible from user-level application code with low overhead.

    Some execution environments might prohibit access to counters, for example, to impede timing side-channel attacks.

    Unresolved include directive in modules/chapters/pages/counters.adoc - include::images/wavedrom/counters-diag.adoc[]

    For base ISAs with XLEN≥64, CSR instructions can access the full 64-bit CSRs directly. In particular, the RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions read the full 64 bits of the cycle, time, and instret counters.

    The counter pseudoinstructions are mapped to the read-only csrrs rd, counter, x0 canonical form, but the other read-only CSR instruction forms (based on CSRRC/CSRRSI/CSRRCI) are also legal ways to read these CSRs.

    For base ISAs with XLEN=32, the Zicntr extension enables the three 64-bit read-only counters to be accessed in 32-bit pieces. The RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions provide the lower 32 bits, and the RDCYCLEH, RDTIMEH, and RDINSTRETH pseudoinstructions provide the upper 32 bits of the respective counters.

    We required the counters be 64 bits wide, even when XLEN=32, as otherwise it is very difficult for software to determine if values have overflowed. For a low-end implementation, the upper 32 bits of each counter can be implemented using software counters incremented by a trap handler triggered by overflow of the lower 32 bits. The sample code given below shows how the full 64-bit width value can be safely read using the individual 32-bit width pseudoinstructions.

    The RDCYCLE pseudoinstruction reads the low XLEN bits of the cycle CSR which holds a count of the number of clock cycles executed by the processor core on which the hart is running from an arbitrary start time in the past. RDCYCLEH is only present when XLEN=32 and reads bits 63-32 of the same cycle counter. The underlying 64-bit counter should never overflow in practice. The rate at which the cycle counter advances will depend on the implementation and operating environment. The execution environment should provide a means to determine the current rate (cycles/second) at which the cycle counter is incrementing.

    RDCYCLE is intended to return the number of cycles executed by the processor core, not the hart. Precisely defining what is a "core" is difficult given some implementation choices (e.g., AMD Bulldozer). Precisely defining what is a "clock cycle" is also difficult given the range of implementations (including software emulations), but the intent is that RDCYCLE is used for performance monitoring along with the other performance counters. In particular, where there is one hart/core, one would expect cycle-count/instructions-retired to measure CPI for a hart.

    Cores don’t have to be exposed to software at all, and an implementor might choose to pretend multiple harts on one physical core are running on separate cores with one hart/core, and provide separate cycle counters for each hart. This might make sense in a simple barrel processor (e.g., CDC 6600 peripheral processors) where inter-hart timing interactions are non-existent or minimal.

    Where there is more than one hart/core and dynamic multithreading, it is not generally possible to separate out cycles per hart (especially with SMT). It might be possible to define a separate performance counter that tried to capture the number of cycles a particular hart was running, but this definition would have to be very fuzzy to cover all the possible threading implementations. For example, should we only count cycles for which any instruction was issued to execution for this hart, and/or cycles any instruction retired, or include cycles this hart was occupying machine resources but couldn’t execute due to stalls while other harts went into execution? Likely, "all of the above" would be needed to have understandable performance stats. This complexity of defining a per-hart cycle count, and also the need in any case for a total per-core cycle count when tuning multithreaded code led to just standardizing the per-core cycle counter, which also happens to work well for the common single hart/core case.

    Standardizing what happens during "sleep" is not practical given that what "sleep" means is not standardized across execution environments, but if the entire core is paused (entirely clock-gated or powered-down in deep sleep), then it is not executing clock cycles, and the cycle count shouldn’t be increasing per the spec. There are many details, e.g., whether clock cycles required to reset a processor after waking up from a power-down event should be counted, and these are considered execution-environment-specific details.

    Even though there is no precise definition that works for all platforms, this is still a useful facility for most platforms, and an imprecise, common, "usually correct" standard here is better than no standard. The intent of RDCYCLE was primarily performance monitoring/tuning, and the specification was written with that goal in mind.

    The RDTIME pseudoinstruction reads the low XLEN bits of the "time" CSR, which counts wall-clock real time that has passed from an arbitrary start time in the past. RDTIMEH is only present when XLEN=32 and reads bits 63-32 of the same real-time counter. The underlying 64-bit counter increments by one with each tick of the real-time clock, and, for realistic real-time clock frequencies, should never overflow in practice. The execution environment should provide a means of determining the period of a counter tick (seconds/tick). The period should be constant within a small error bound. The environment should provide a means to determine the accuracy of the clock (i.e., the maximum relative error between the nominal and actual real-time clock periods).

    On some simple platforms, cycle count might represent a valid implementation of RDTIME, in which case RDTIME and RDCYCLE may return the same result.

    It is difficult to provide a strict mandate on clock period given the wide variety of possible implementation platforms. The maximum error bound should be set based on the requirements of the platform.

    The real-time clocks of all harts must be synchronized to within one tick of the real-time clock.

    As with other architectural mandates, it suffices to appear "as if" harts are synchronized to within one tick of the real-time clock, i.e., software is unable to observe that there is a greater delta between the real-time clock values observed on two harts.

    The RDINSTRET pseudoinstruction reads the low XLEN bits of the instret CSR, which counts the number of instructions retired by this hart from some arbitrary start point in the past. RDINSTRETH is only present when XLEN=32 and reads bits 63-32 of the same instruction counter. The underlying 64-bit counter should never overflow in practice.

    Instructions that cause synchronous exceptions, including ECALL and EBREAK, are not considered to retire and hence do not increment the instret CSR.

    The following code sequence will read a valid 64-bit cycle counter value into x3:x2, even if the counter overflows its lower half between reading its upper and lower halves.

    Sample code for reading the 64-bit cycle counter when XLEN=32.
    again:
        rdcycleh     x3
        rdcycle      x2
        rdcycleh     x4
        bne          x3, x4, again
    "Zihpm" Extension for Hardware Performance Counters
    The Zihpm extension comprises up to 29 additional unprivileged 64-bit hardware performance counters, hpmcounter3-hpmcounter31. When XLEN=32, the upper 32 bits of these performance counters are accessible via additional CSRs hpmcounter3h- hpmcounter31h. The Zihpm extension depends on the Zicsr extension.

    In some applications, it is important to be able to read multiple counters at the same instant in time. When run under a multitasking environment, a user thread can suffer a context switch while attempting to read the counters. One solution is for the user thread to read the real-time counter before and after reading the other counters to determine if a context switch occurred in the middle of the sequence, in which case the reads can be retried. We considered adding output latches to allow a user thread to snapshot the counter values atomically, but this would increase the size of the user context, especially for implementations with a richer set of counters.

    The implemented number and width of these additional counters, and the set of events they count, is platform-specific. Accessing an unimplemented or ill-configured counter may cause an illegal-instruction exception or may return a constant value.

    The execution environment should provide a means to determine the number and width of the implemented counters, and an interface to configure the events to be counted by each counter.

    For execution environments implemented on RISC-V privileged platforms, the privileged architecture manual describes privileged CSRs controlling access by lower privileged modes to these counters, and to set the events to be counted.

    Alternative execution environments (e.g., user-level-only software performance models) may provide alternative mechanisms to configure the events counted by the performance counters.

    It would be useful to eventually standardize event settings to count ISA-level metrics, such as the number of floating-point instructions executed for example, and possibly a few common microarchitectural metrics, such as "L1 instruction cache misses".
  
  metrics:
    unique_concepts_identified: 16
    validated_valid_parameters: 11
    identified_hallucinations: 5

  valid_parameters:
    - name: access_prohibition
      description: "Ability for the environment to prohibit counter access to prevent timing attacks."
      type: boolean
      constraints: implementation-specific
    - name: upper_bits_impl
      description: "For RV32, whether upper 32 bits are hardware-backed or software trap-handled."
      type: enum
      constraints: hardware or software trap-handler
    - name: cycle_counter_rate
      description: "The frequency at which the cycle counter increments."
      type: integer
      constraints: depends on implementation and operating environment
    - name: rdcycle_mapping
      description: "Decision to map RDCYCLE resource to a specific core or a specific hart."
      type: enum
      constraints: per-core or per-hart
    - name: sleep_behavior
      description: "Determines if cycle count increases when core is paused/clock-gated."
      type: enum
      constraints: stop or continue counting
    - name: reset_counting
      description: "Whether cycles required for processor reset after wake-up are counted."
      type: boolean
      constraints: implementation-defined
    - name: clock_accuracy
      description: "Maximum relative error/drift between nominal and actual clock period."
      type: range
      constraints: implementation-defined maximum error bound
    - name: rdtime_source
      description: "Hardware source for time value (dedicated RTC or cycle counter alias)."
      type: enum
      constraints: platform-specific
    - name: hpm_counter_count
      description: "Total number of additional performance counters implemented."
      type: range
      constraints: 0 to 29
    - name: hpm_counter_width
      description: "The bit-width of implemented hardware performance counters."
      type: integer
      constraints: platform-specific
    - name: event_mapping
      description: "The set of architectural events mapped to each HPM counter."
      type: structural
      constraints: platform-specific event set

  hallucinations_rejected:
    - name: counter_width_64
      reason: "Mandated by spec; not a designer choice."
    - name: rdtimeh_presence
      reason: "Fixed requirement for XLEN=32; not a parameter."
    - name: hart_synchronization
      reason: "Compliance mandate; not a hardware configuration knob."
    - name: xlen_mapping_logic
      reason: "Fixed by ISA architectural specification."
    - name: overflow_property
      reason: "Mathematical inevitability; not a configurable parameter."

CONCLUSION:
    The transition from keyword-based prompts to reasoning-based (Chain-of-Thought) 
    instruction significantly improved extraction. 
    While LLMs still struggle with subtle linguistic differences between mandates 
    and options (hallucination rate ~31% in complex sections), the methodology 
    effectively filters out the vast majority of fixed ISA constants.
  