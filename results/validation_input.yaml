- Results of final prompt on Zicntr and Zihpm snippet for validation

- prompting_technique: test1
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\n\"Zicntr\" and \"Zihpm\" Extensions for Counters, Version 2.0\nRISC-V\
    \ ISAs provide a set of up to thirty-two 64-bit performance counters and timers\
    \ that are accessible via unprivileged XLEN-bit read-only CSR registers 0xC00\u2013\
    0xC1F (when XLEN=32, the upper 32 bits are accessed via CSR registers 0xC80\u2013\
    0xC9F). These counters are divided between the \"Zicntr\" and \"Zihpm\" extensions.\n\
    \n\"Zicntr\" Extension for Base Counters and Timers\nThe Zicntr standard extension\
    \ comprises the first three of these counters (CYCLE, TIME, and INSTRET), which\
    \ have dedicated functions (cycle count, real-time clock, and instructions retired,\
    \ respectively). The Zicntr extension depends on the Zicsr extension.\n\nWe recommend\
    \ provision of these basic counters in implementations as they are essential for\
    \ basic performance analysis, adaptive and dynamic optimization, and to allow\
    \ an application to work with real-time streams. Additional counters in the separate\
    \ Zihpm extension can help diagnose performance problems and these should be made\
    \ accessible from user-level application code with low overhead.\n\nSome execution\
    \ environments might prohibit access to counters, for example, to impede timing\
    \ side-channel attacks.\n"
  input:
    text: "\"Zicntr\" and \"Zihpm\" Extensions for Counters, Version 2.0\nRISC-V ISAs\
      \ provide a set of up to thirty-two 64-bit performance counters and timers that\
      \ are accessible via unprivileged XLEN-bit read-only CSR registers 0xC00\u2013\
      0xC1F (when XLEN=32, the upper 32 bits are accessed via CSR registers 0xC80\u2013\
      0xC9F). These counters are divided between the \"Zicntr\" and \"Zihpm\" extensions.\n\
      \n\"Zicntr\" Extension for Base Counters and Timers\nThe Zicntr standard extension\
      \ comprises the first three of these counters (CYCLE, TIME, and INSTRET), which\
      \ have dedicated functions (cycle count, real-time clock, and instructions retired,\
      \ respectively). The Zicntr extension depends on the Zicsr extension.\n\nWe\
      \ recommend provision of these basic counters in implementations as they are\
      \ essential for basic performance analysis, adaptive and dynamic optimization,\
      \ and to allow an application to work with real-time streams. Additional counters\
      \ in the separate Zihpm extension can help diagnose performance problems and\
      \ these should be made accessible from user-level application code with low\
      \ overhead.\n\nSome execution environments might prohibit access to counters,\
      \ for example, to impede timing side-channel attacks."
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: access_prohibition
        description: Indicates whether some execution environments might prohibit
          access to counters.
        type: boolean
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: zicntr_extension
        description: Zicntr extension type
        type: bool
        constraints: unspecified
      - name: access_prohibition
        description: Counter access prohibition
        type: bool
        constraints: unspecified
- prompting_technique: test1
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nSome execution environments might prohibit access to counters, for example,\
    \ to impede timing side-channel attacks.\n\nUnresolved include directive in modules/chapters/pages/counters.adoc\
    \ - include::images/wavedrom/counters-diag.adoc[]\n\nFor base ISAs with XLEN\u2265\
    64, CSR instructions can access the full 64-bit CSRs directly. In particular,\
    \ the RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions read the full 64 bits\
    \ of the cycle, time, and instret counters.\n\nThe counter pseudoinstructions\
    \ are mapped to the read-only csrrs rd, counter, x0 canonical form, but the other\
    \ read-only CSR instruction forms (based on CSRRC/CSRRSI/CSRRCI) are also legal\
    \ ways to read these CSRs.\n\nFor base ISAs with XLEN=32, the Zicntr extension\
    \ enables the three 64-bit read-only counters to be accessed in 32-bit pieces.\
    \ The RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions provide the lower 32 bits,\
    \ and the RDCYCLEH, RDTIMEH, and RDINSTRETH pseudoinstructions provide the upper\
    \ 32 bits of the respective counters.\n"
  input:
    text: "Some execution environments might prohibit access to counters, for example,\
      \ to impede timing side-channel attacks.\n\nUnresolved include directive in\
      \ modules/chapters/pages/counters.adoc - include::images/wavedrom/counters-diag.adoc[]\n\
      \nFor base ISAs with XLEN\u226564, CSR instructions can access the full 64-bit\
      \ CSRs directly. In particular, the RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions\
      \ read the full 64 bits of the cycle, time, and instret counters.\n\nThe counter\
      \ pseudoinstructions are mapped to the read-only csrrs rd, counter, x0 canonical\
      \ form, but the other read-only CSR instruction forms (based on CSRRC/CSRRSI/CSRRCI)\
      \ are also legal ways to read these CSRs.\n\nFor base ISAs with XLEN=32, the\
      \ Zicntr extension enables the three 64-bit read-only counters to be accessed\
      \ in 32-bit pieces. The RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions provide\
      \ the lower 32 bits, and the RDCYCLEH, RDTIMEH, and RDINSTRETH pseudoinstructions\
      \ provide the upper 32 bits of the respective counters."
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: access_to_counters
        description: Whether access to counters is prohibited in some execution environments.
        type: boolean
        constraints: unspecified
      - name: zicntr_extension
        description: Enables the three 64-bit read-only counters to be accessed in
          32-bit pieces for base ISAs with XLEN=32.
        type: boolean
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: access_prohibited
        description: Whether access to counters is prohibited.
        type: boolean
        constraints: unspecified
      - name: xlen_limit
        description: The minimum value of XLEN.
        type: integer
        constraints: '64'
      - name: csr_instruction_behavior
        description: Behavior of CSR instructions for accessing 64-bit CSRs.
        type: string
        constraints: unspecified
      - name: csr_extension
        description: Whether the Zicntr extension is enabled.
        type: boolean
        constraints: unspecified
      - name: counter_access_mode
        description: The mode of accessing 64-bit counters.
        type: enum
        constraints: full, upper, lower
- prompting_technique: test1
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nWe required the counters be 64 bits wide, even when XLEN=32, as otherwise\
    \ it is very difficult for software to determine if values have overflowed. For\
    \ a low-end implementation, the upper 32 bits of each counter can be implemented\
    \ using software counters incremented by a trap handler triggered by overflow\
    \ of the lower 32 bits. The sample code given below shows how the full 64-bit\
    \ width value can be safely read using the individual 32-bit width pseudoinstructions.\n\
    \nThe RDCYCLE pseudoinstruction reads the low XLEN bits of the cycle CSR which\
    \ holds a count of the number of clock cycles executed by the processor core on\
    \ which the hart is running from an arbitrary start time in the past. RDCYCLEH\
    \ is only present when XLEN=32 and reads bits 63-32 of the same cycle counter.\
    \ The underlying 64-bit counter should never overflow in practice. The rate at\
    \ which the cycle counter advances will depend on the implementation and operating\
    \ environment. The execution environment should provide a means to determine the\
    \ current rate (cycles/second) at which the cycle counter is incrementing.\n"
  input:
    text: 'We required the counters be 64 bits wide, even when XLEN=32, as otherwise
      it is very difficult for software to determine if values have overflowed. For
      a low-end implementation, the upper 32 bits of each counter can be implemented
      using software counters incremented by a trap handler triggered by overflow
      of the lower 32 bits. The sample code given below shows how the full 64-bit
      width value can be safely read using the individual 32-bit width pseudoinstructions.


      The RDCYCLE pseudoinstruction reads the low XLEN bits of the cycle CSR which
      holds a count of the number of clock cycles executed by the processor core on
      which the hart is running from an arbitrary start time in the past. RDCYCLEH
      is only present when XLEN=32 and reads bits 63-32 of the same cycle counter.
      The underlying 64-bit counter should never overflow in practice. The rate at
      which the cycle counter advances will depend on the implementation and operating
      environment. The execution environment should provide a means to determine the
      current rate (cycles/second) at which the cycle counter is incrementing.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: upper_bits_implementation
        description: For a low-end implementation, the upper 32 bits of each counter
          can be implemented using software counters.
        type: boolean
        constraints: unspecified
      - name: cycle_counter_rate
        description: The rate at which the cycle counter advances depends on the implementation
          and operating environment.
        type: range
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: counter_width
        description: The width of the counters, even when XLEN=32.
        type: enum
        constraints: '64'
      - name: upper_bit_behavior
        description: Behavior of bits [63:32] of the counters.
        type: string
        constraints: may be implemented using software counters incremented by a trap
          handler
      - name: cycle_counter_overflow_behavior
        description: Behavior when the underlying 64-bit counter overflows.
        type: string
        constraints: should never occur in practice
      - name: cycle_counter_rate
        description: The rate at which the cycle counter is incrementing.
        type: range
        constraints: unspecified
- prompting_technique: test1
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nRDCYCLE is intended to return the number of cycles executed by the processor\
    \ core, not the hart. Precisely defining what is a \"core\" is difficult given\
    \ some implementation choices (e.g., AMD Bulldozer). Precisely defining what is\
    \ a \"clock cycle\" is also difficult given the range of implementations (including\
    \ software emulations), but the intent is that RDCYCLE is used for performance\
    \ monitoring along with the other performance counters. In particular, where there\
    \ is one hart/core, one would expect cycle-count/instructions-retired to measure\
    \ CPI for a hart.\n\nCores don\u2019t have to be exposed to software at all, and\
    \ an implementor might choose to pretend multiple harts on one physical core are\
    \ running on separate cores with one hart/core, and provide separate cycle counters\
    \ for each hart. This might make sense in a simple barrel processor (e.g., CDC\
    \ 6600 peripheral processors) where inter-hart timing interactions are non-existent\
    \ or minimal.\n"
  input:
    text: "RDCYCLE is intended to return the number of cycles executed by the processor\
      \ core, not the hart. Precisely defining what is a \"core\" is difficult given\
      \ some implementation choices (e.g., AMD Bulldozer). Precisely defining what\
      \ is a \"clock cycle\" is also difficult given the range of implementations\
      \ (including software emulations), but the intent is that RDCYCLE is used for\
      \ performance monitoring along with the other performance counters. In particular,\
      \ where there is one hart/core, one would expect cycle-count/instructions-retired\
      \ to measure CPI for a hart.\n\nCores don\u2019t have to be exposed to software\
      \ at all, and an implementor might choose to pretend multiple harts on one physical\
      \ core are running on separate cores with one hart/core, and provide separate\
      \ cycle counters for each hart. This might make sense in a simple barrel processor\
      \ (e.g., CDC 6600 peripheral processors) where inter-hart timing interactions\
      \ are non-existent or minimal."
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: core_definition
        description: Definition of what constitutes a 'core' in the context of cycle
          counting.
        type: structural
        constraints: unspecified
      - name: cycle_counter_per_hart
        description: Whether to provide separate cycle counters for each hart.
        type: boolean
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: core_definition
        description: Definition of a core, considering software emulations and implementation
          choices.
        type: string
        constraints: unspecified
      - name: clock_cycle_definition
        description: Definition of a clock cycle, considering software emulations
          and implementation choices.
        type: string
        constraints: unspecified
      - name: cycle_counter_exposure
        description: Whether cores are exposed to software or not.
        type: boolean
        constraints: unspecified
      - name: hart_core_mapping
        description: Mapping between harts and cores.
        type: enum
        constraints: physical, separate_cores
- prompting_technique: test1
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nWhere there is more than one hart/core and dynamic multithreading, it\
    \ is not generally possible to separate out cycles per hart (especially with SMT).\
    \ It might be possible to define a separate performance counter that tried to\
    \ capture the number of cycles a particular hart was running, but this definition\
    \ would have to be very fuzzy to cover all the possible threading implementations.\
    \ For example, should we only count cycles for which any instruction was issued\
    \ to execution for this hart, and/or cycles any instruction retired, or include\
    \ cycles this hart was occupying machine resources but couldn\u2019t execute due\
    \ to stalls while other harts went into execution? Likely, \"all of the above\"\
    \ would be needed to have understandable performance stats. This complexity of\
    \ defining a per-hart cycle count, and also the need in any case for a total per-core\
    \ cycle count when tuning multithreaded code led to just standardizing the per-core\
    \ cycle counter, which also happens to work well for the common single hart/core\
    \ case.\n"
  input:
    text: "Where there is more than one hart/core and dynamic multithreading, it is\
      \ not generally possible to separate out cycles per hart (especially with SMT).\
      \ It might be possible to define a separate performance counter that tried to\
      \ capture the number of cycles a particular hart was running, but this definition\
      \ would have to be very fuzzy to cover all the possible threading implementations.\
      \ For example, should we only count cycles for which any instruction was issued\
      \ to execution for this hart, and/or cycles any instruction retired, or include\
      \ cycles this hart was occupying machine resources but couldn\u2019t execute\
      \ due to stalls while other harts went into execution? Likely, \"all of the\
      \ above\" would be needed to have understandable performance stats. This complexity\
      \ of defining a per-hart cycle count, and also the need in any case for a total\
      \ per-core cycle count when tuning multithreaded code led to just standardizing\
      \ the per-core cycle counter, which also happens to work well for the common\
      \ single hart/core case."
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cycle_count_definition
        description: Definition of how cycles are counted per hart/core.
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cycle_count_method
        description: Method to count cycles per hart/core in the presence of SMT and
          dynamic multithreading.
        type: enum
        constraints: unspecified
      - name: instruction_issue_criteria
        description: Criteria to count instruction issues for a hart/core in the presence
          of SMT and dynamic multithreading.
        type: enum
        constraints: unspecified
      - name: instruction_retirement_criteria
        description: Criteria to count instruction retires for a hart/core in the
          presence of SMT and dynamic multithreading.
        type: enum
        constraints: unspecified
      - name: machine_resources_occupation_criteria
        description: Criteria to count cycles a hart/core occupies machine resources
          but cannot execute due to stalls.
        type: enum
        constraints: unspecified
- prompting_technique: test1
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nStandardizing what happens during \"sleep\" is not practical given that\
    \ what \"sleep\" means is not standardized across execution environments, but\
    \ if the entire core is paused (entirely clock-gated or powered-down in deep sleep),\
    \ then it is not executing clock cycles, and the cycle count shouldn\u2019t be\
    \ increasing per the spec. There are many details, e.g., whether clock cycles\
    \ required to reset a processor after waking up from a power-down event should\
    \ be counted, and these are considered execution-environment-specific details.\n\
    \nEven though there is no precise definition that works for all platforms, this\
    \ is still a useful facility for most platforms, and an imprecise, common, \"\
    usually correct\" standard here is better than no standard. The intent of RDCYCLE\
    \ was primarily performance monitoring/tuning, and the specification was written\
    \ with that goal in mind.\n"
  input:
    text: "Standardizing what happens during \"sleep\" is not practical given that\
      \ what \"sleep\" means is not standardized across execution environments, but\
      \ if the entire core is paused (entirely clock-gated or powered-down in deep\
      \ sleep), then it is not executing clock cycles, and the cycle count shouldn\u2019\
      t be increasing per the spec. There are many details, e.g., whether clock cycles\
      \ required to reset a processor after waking up from a power-down event should\
      \ be counted, and these are considered execution-environment-specific details.\n\
      \nEven though there is no precise definition that works for all platforms, this\
      \ is still a useful facility for most platforms, and an imprecise, common, \"\
      usually correct\" standard here is better than no standard. The intent of RDCYCLE\
      \ was primarily performance monitoring/tuning, and the specification was written\
      \ with that goal in mind."
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: core_paused_cycle_count
        description: Whether the cycle count increases when the entire core is paused.
        type: boolean
        constraints: unspecified
      - name: reset_cycle_count_after_wakeup
        description: Whether clock cycles required to reset a processor after waking
          up from a power-down event should be counted.
        type: boolean
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: clock_cycle_behavior
        description: Behavior of clock cycle count during sleep.
        type: string
        constraints: unspecified
      - name: cycle_counting_after_reset
        description: Whether clock cycles required to reset after wake-up should be
          counted.
        type: boolean
        constraints: unspecified
- prompting_technique: test2
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nThe RDTIME pseudoinstruction reads the low XLEN bits of the \"time\"\
    \ CSR, which counts wall-clock real time that has passed from an arbitrary start\
    \ time in the past. RDTIMEH is only present when XLEN=32 and reads bits 63-32\
    \ of the same real-time counter. The underlying 64-bit counter increments by one\
    \ with each tick of the real-time clock, and, for realistic real-time clock frequencies,\
    \ should never overflow in practice. The execution environment should provide\
    \ a means of determining the period of a counter tick (seconds/tick). The period\
    \ should be constant within a small error bound. The environment should provide\
    \ a means to determine the accuracy of the clock (i.e., the maximum relative error\
    \ between the nominal and actual real-time clock periods).\n\nOn some simple platforms,\
    \ cycle count might represent a valid implementation of RDTIME, in which case\
    \ RDTIME and RDCYCLE may return the same result.\n\nIt is difficult to provide\
    \ a strict mandate on clock period given the wide variety of possible implementation\
    \ platforms. The maximum error bound should be set based on the requirements of\
    \ the platform.\n"
  input:
    text: 'The RDTIME pseudoinstruction reads the low XLEN bits of the "time" CSR,
      which counts wall-clock real time that has passed from an arbitrary start time
      in the past. RDTIMEH is only present when XLEN=32 and reads bits 63-32 of the
      same real-time counter. The underlying 64-bit counter increments by one with
      each tick of the real-time clock, and, for realistic real-time clock frequencies,
      should never overflow in practice. The execution environment should provide
      a means of determining the period of a counter tick (seconds/tick). The period
      should be constant within a small error bound. The environment should provide
      a means to determine the accuracy of the clock (i.e., the maximum relative error
      between the nominal and actual real-time clock periods).


      On some simple platforms, cycle count might represent a valid implementation
      of RDTIME, in which case RDTIME and RDCYCLE may return the same result.


      It is difficult to provide a strict mandate on clock period given the wide variety
      of possible implementation platforms. The maximum error bound should be set
      based on the requirements of the platform.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: rdtimeh_presence
        description: Indicates whether the RDTIMEH instruction is present.
        type: boolean
        constraints: unspecified
      - name: counter_tick_period_accuracy
        description: The accuracy of the clock period provided by the execution environment.
        type: range
        constraints: unspecified
      - name: rdtime_cycle_count_equivalence
        description: Whether RDTIME and RDCYCLE return the same result on some platforms.
        type: boolean
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: clock_frequency
        description: Realistic frequency of the real-time clock.
        type: range
        constraints: unspecified
      - name: clock_period
        description: Period of a counter tick in seconds.
        type: integer
        constraints: unspecified
      - name: clock_accuracy
        description: Maximum relative error between nominal and actual real-time clock
          periods.
        type: range
        constraints: unspecified
      - name: error_bound
        description: Maximum error bound for the clock period.
        type: integer
        constraints: unspecified
      - name: cycle_count
        description: Implementation of RDTIME using cycle count.
        type: boolean
        constraints: unspecified
- prompting_technique: test2
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nThe real-time clocks of all harts must be synchronized to within one\
    \ tick of the real-time clock.\n\nAs with other architectural mandates, it suffices\
    \ to appear \"as if\" harts are synchronized to within one tick of the real-time\
    \ clock, i.e., software is unable to observe that there is a greater delta between\
    \ the real-time clock values observed on two harts.\n\nThe RDINSTRET pseudoinstruction\
    \ reads the low XLEN bits of the instret CSR, which counts the number of instructions\
    \ retired by this hart from some arbitrary start point in the past. RDINSTRETH\
    \ is only present when XLEN=32 and reads bits 63-32 of the same instruction counter.\
    \ The underlying 64-bit counter should never overflow in practice.\n\nInstructions\
    \ that cause synchronous exceptions, including ECALL and EBREAK, are not considered\
    \ to retire and hence do not increment the instret CSR.\n\nThe following code\
    \ sequence will read a valid 64-bit cycle counter value into x3:x2, even if the\
    \ counter overflows its lower half between reading its upper and lower halves.\n"
  input:
    text: 'The real-time clocks of all harts must be synchronized to within one tick
      of the real-time clock.


      As with other architectural mandates, it suffices to appear "as if" harts are
      synchronized to within one tick of the real-time clock, i.e., software is unable
      to observe that there is a greater delta between the real-time clock values
      observed on two harts.


      The RDINSTRET pseudoinstruction reads the low XLEN bits of the instret CSR,
      which counts the number of instructions retired by this hart from some arbitrary
      start point in the past. RDINSTRETH is only present when XLEN=32 and reads bits
      63-32 of the same instruction counter. The underlying 64-bit counter should
      never overflow in practice.


      Instructions that cause synchronous exceptions, including ECALL and EBREAK,
      are not considered to retire and hence do not increment the instret CSR.


      The following code sequence will read a valid 64-bit cycle counter value into
      x3:x2, even if the counter overflows its lower half between reading its upper
      and lower halves.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters: []
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: sync_tick
        description: The real-time clocks of all harts must be synchronized to within
          one tick of the real-time clock.
        type: string
        constraints: unspecified
- prompting_technique: test2
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nThe following code sequence will read a valid 64-bit cycle counter value\
    \ into x3:x2, even if the counter overflows its lower half between reading its\
    \ upper and lower halves.\n\nSample code for reading the 64-bit cycle counter\
    \ when XLEN=32.\n    again:\n        rdcycleh     x3\n        rdcycle      x2\n\
    \        rdcycleh     x4\n        bne          x3, x4, again\n\"Zihpm\" Extension\
    \ for Hardware Performance Counters\nThe Zihpm extension comprises up to 29 additional\
    \ unprivileged 64-bit hardware performance counters, hpmcounter3-hpmcounter31.\
    \ When XLEN=32, the upper 32 bits of these performance counters are accessible\
    \ via additional CSRs hpmcounter3h- hpmcounter31h. The Zihpm extension depends\
    \ on the Zicsr extension.\n"
  input:
    text: "The following code sequence will read a valid 64-bit cycle counter value\
      \ into x3:x2, even if the counter overflows its lower half between reading its\
      \ upper and lower halves.\n\nSample code for reading the 64-bit cycle counter\
      \ when XLEN=32.\n    again:\n        rdcycleh     x3\n        rdcycle      x2\n\
      \        rdcycleh     x4\n        bne          x3, x4, again\n\"Zihpm\" Extension\
      \ for Hardware Performance Counters\nThe Zihpm extension comprises up to 29\
      \ additional unprivileged 64-bit hardware performance counters, hpmcounter3-hpmcounter31.\
      \ When XLEN=32, the upper 32 bits of these performance counters are accessible\
      \ via additional CSRs hpmcounter3h- hpmcounter31h. The Zihpm extension depends\
      \ on the Zicsr extension."
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: number_of_hpm_counters
        description: The number of additional unprivileged 64-bit hardware performance
          counters.
        type: range
        constraints: 0-29
      - name: upper_bits_accessibility
        description: Behavior of accessing the upper 32 bits of the performance counters
          when XLEN=32.
        type: boolean
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cycle_counter_width
        description: The bit-width of the cycle counter.
        type: enum
        constraints: '64'
      - name: overflow_behavior
        description: Behavior when the cycle counter overflows its lower half.
        type: string
        constraints: unspecified
- prompting_technique: test2
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nIn some applications, it is important to be able to read multiple counters\
    \ at the same instant in time. When run under a multitasking environment, a user\
    \ thread can suffer a context switch while attempting to read the counters. One\
    \ solution is for the user thread to read the real-time counter before and after\
    \ reading the other counters to determine if a context switch occurred in the\
    \ middle of the sequence, in which case the reads can be retried. We considered\
    \ adding output latches to allow a user thread to snapshot the counter values\
    \ atomically, but this would increase the size of the user context, especially\
    \ for implementations with a richer set of counters.\n\nThe implemented number\
    \ and width of these additional counters, and the set of events they count, is\
    \ platform-specific. Accessing an unimplemented or ill-configured counter may\
    \ cause an illegal-instruction exception or may return a constant value.\n\nThe\
    \ execution environment should provide a means to determine the number and width\
    \ of the implemented counters, and an interface to configure the events to be\
    \ counted by each counter.\n"
  input:
    text: 'In some applications, it is important to be able to read multiple counters
      at the same instant in time. When run under a multitasking environment, a user
      thread can suffer a context switch while attempting to read the counters. One
      solution is for the user thread to read the real-time counter before and after
      reading the other counters to determine if a context switch occurred in the
      middle of the sequence, in which case the reads can be retried. We considered
      adding output latches to allow a user thread to snapshot the counter values
      atomically, but this would increase the size of the user context, especially
      for implementations with a richer set of counters.


      The implemented number and width of these additional counters, and the set of
      events they count, is platform-specific. Accessing an unimplemented or ill-configured
      counter may cause an illegal-instruction exception or may return a constant
      value.


      The execution environment should provide a means to determine the number and
      width of the implemented counters, and an interface to configure the events
      to be counted by each counter.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: number_of_counters
        description: The implemented number of additional counters.
        type: integer
        constraints: unspecified
      - name: width_of_counters
        description: The width of the implemented counters.
        type: integer
        constraints: unspecified
      - name: events_counted_by_counters
        description: The set of events each counter counts, which is platform-specific.
        type: structural
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: num_counters
        description: The number of additional counters implemented.
        type: integer
        constraints: unspecified
      - name: counter_width
        description: The width of the implemented counters.
        type: integer
        constraints: unspecified
      - name: counter_events
        description: The set of events counted by each implemented counter.
        type: enum
        constraints: unspecified
- prompting_technique: test2
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32.\n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nThe execution environment should provide a means to determine the number\
    \ and width of the implemented counters, and an interface to configure the events\
    \ to be counted by each counter.\n\nFor execution environments implemented on\
    \ RISC-V privileged platforms, the privileged architecture manual describes privileged\
    \ CSRs controlling access by lower privileged modes to these counters, and to\
    \ set the events to be counted.\n\nAlternative execution environments (e.g., user-level-only\
    \ software performance models) may provide alternative mechanisms to configure\
    \ the events counted by the performance counters.\n\nIt would be useful to eventually\
    \ standardize event settings to count ISA-level metrics, such as the number of\
    \ floating-point instructions executed for example, and possibly a few common\
    \ microarchitectural metrics, such as \"L1 instruction cache misses\".\n"
  input:
    text: 'The execution environment should provide a means to determine the number
      and width of the implemented counters, and an interface to configure the events
      to be counted by each counter.


      For execution environments implemented on RISC-V privileged platforms, the privileged
      architecture manual describes privileged CSRs controlling access by lower privileged
      modes to these counters, and to set the events to be counted.


      Alternative execution environments (e.g., user-level-only software performance
      models) may provide alternative mechanisms to configure the events counted by
      the performance counters.


      It would be useful to eventually standardize event settings to count ISA-level
      metrics, such as the number of floating-point instructions executed for example,
      and possibly a few common microarchitectural metrics, such as "L1 instruction
      cache misses".'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: counter_number
        description: The number of implemented counters.
        type: integer
        constraints: unspecified
      - name: counter_width
        description: The width of each implemented counter.
        type: integer
        constraints: unspecified
      - name: event_configuration_mechanism
        description: The mechanism provided by the execution environment to configure
          the events to be counted by each counter.
        type: structural
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: counter_width
        description: Width of implemented counters
        type: enum
        constraints: unspecified
      - name: event_config
        description: Interface to configure events to be counted by each counter
        type: string
        constraints: unspecified
      - name: event_settings
        description: Standardized event settings for ISA-level metrics and microarchitectural
          metrics
        type: string
        constraints: unspecified
