- All Prompts and their results for both models.

- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words implies a parameter:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 19.3.1:

    Caches organize copies of data into cache blocks, each of which represents a contiguous,
    naturally aligned power-of-two (or NAPOT) range of memory locations. A cache block
    is identified by any of the physical addresses corresponding to the underlying
    memory locations. The capacity and organization of a cache and the size of a cache
    block are both implementation-specific, and the execution environment provides
    software a means to discover information about the caches and cache blocks in
    a system. In the initial set of CMO extensions, the size of a cache block shall
    be uniform throughout the system.


    '
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: Capacity of a cache
        type: integer
        constraints: implementation-specific
      - name: cache_organization
        description: Organization of a cache
        type: structural
        constraints: implementation-specific
      - name: cache_block_size
        description: Size of a cache block
        type: integer
        constraints: shall be uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: The size of a cache block
        type: unspecified
        constraints: implementation specific
      - name: cache_capacity
        description: The capacity of a cache
        type: unspecified
        constraints: implementation specific
      - name: cache_organization
        description: The organization of a cache
        type: unspecified
        constraints: implementation specific
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words implies a parameter:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 2.1:

    "Conventional" R/W accessibility of CSRs according to address mapping

    The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
    to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
    are used to encode the read and write accessibility of the CSRs according to privilege
    level as shown in Table 1. The top two bits (csr[11:10]) indicate whether the
    register is read/write (00,01, or 10) or read-only (11). The next two bits (csr[9:8])
    encode the lowest privilege level that can access the CSR.


    '
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_accessibility
        description: Top two bits (csr[11:10]) indicate whether the register is read/write
          (00,01, or 10) or read-only (11)
        type: bitfield
        constraints: unspecified
      - name: lowest_privilege_level
        description: Next two bits (csr[9:8]) encode the lowest privilege level that
          can access the CSR
        type: bitfield
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr[11:10]
        description: Indicates whether the register is read/write or read-only
        type: enum
        constraints: '00: read/write, 01: read/write, 10: read/write, 11: read-only'
      - name: csr[9:8]
        description: Encodes the lowest privilege level that can access the CSR
        type: enum
        constraints: unspecified
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words usually implies a parameter so put extra focus on
    them:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific

    but it maybe that the above words are not present but a parameter is defined.


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 19.3.1:

    Caches organize copies of data into cache blocks, each of which represents a contiguous,
    naturally aligned power-of-two (or NAPOT) range of memory locations. A cache block
    is identified by any of the physical addresses corresponding to the underlying
    memory locations. The capacity and organization of a cache and the size of a cache
    block are both implementation-specific, and the execution environment provides
    software a means to discover information about the caches and cache blocks in
    a system. In the initial set of CMO extensions, the size of a cache block shall
    be uniform throughout the system.


    '
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: Capacity of a cache
        type: integer
        constraints: implementation-specific
      - name: cache_organization
        description: Organization of a cache
        type: structural
        constraints: implementation-specific
      - name: cache_block_size
        description: Size of a cache block
        type: integer
        constraints: shall be uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: Size of a cache block
        type: unspecified
        constraints: implementation-specific
      - name: cache_capacity
        description: Capacity and organization of a cache
        type: unspecified
        constraints: implementation-specific
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words usually implies a parameter so put extra focus on
    them:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific

    but it maybe that the above words are not present but a parameter is defined.


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 2.1:

    "Conventional" R/W accessibility of CSRs according to address mapping

    The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
    to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
    are used to encode the read and write accessibility of the CSRs according to privilege
    level as shown in Table 1. The top two bits (csr[11:10]) indicate whether the
    register is read/write (00,01, or 10) or read-only (11). The next two bits (csr[9:8])
    encode the lowest privilege level that can access the CSR.


    '
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr[11:10]
        description: Top two bits indicating whether the register is read/write (00,01,
          or 10) or read-only (11).
        type: enum
        constraints: 'Enum values: 00, 01, 10, 11'
      - name: csr[9:8]
        description: Next two bits encoding the lowest privilege level that can access
          the CSR.
        type: bitfield
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr[11:8]
        description: Upper 4 bits of the CSR address encoding read and write accessibility
          of CSRs according to privilege level
        type: enum
        constraints: unspecified
      - name: csr[11:10]
        description: Top two bits indicating whether the register is read/write or
          read-only
        type: enum
        constraints: '01: read/write, 10: read-only, 11: read-only'
      - name: csr[9:8]
        description: Encodes the lowest privilege level that can access the CSR
        type: enum
        constraints: unspecified
- prompting_technique: zero_shot3
  prompt: '

    RISC-V is an Open Standard Instruction Set Architecture (ISA).

    To put it simply, an ISA is the language that a computer''s hardware speaks. It
    defines the set of instructions (like add, subtract, load, or store) that a processor
    can execute.


    Architectural Parameters are the variables of a hardware design. They are the
    specific values or behaviors that the hardware designer must decide on and the
    software must account for.


    There are two main types of parameters:

    Fixed Parameters (Standard): These are defined by the ISA and cannot be changed.

    Implementation-Specific Parameters: The ISA says these must exist, but the chip
    designer chooses the value.


    You are a expert in RISC-V.


    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words usually implies a parameter so put extra focus on
    them:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific

    but it maybe that the above words are not present but a parameter is defined.


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write unspecified


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 19.3.1:

    Caches organize copies of data into cache blocks, each of which represents a contiguous,
    naturally aligned power-of-two (or NAPOT) range of memory locations. A cache block
    is identified by any of the physical addresses corresponding to the underlying
    memory locations. The capacity and organization of a cache and the size of a cache
    block are both implementation-specific, and the execution environment provides
    software a means to discover information about the caches and cache blocks in
    a system. In the initial set of CMO extensions, the size of a cache block shall
    be uniform throughout the system.


    '
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: Cache Capacity
        description: Capacity of a cache
        type: integer
        constraints: implementation-specific
      - name: Cache Organization
        description: Organization of a cache
        type: structural
        constraints: implementation-specific
      - name: Cache Block Size
        description: Size of a cache block, which shall be uniform throughout the
          system
        type: integer
        constraints: uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: Size of a cache block
        type: integer
        constraints: unspecified
      - name: cache_capacity
        description: Capacity of a cache
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: Organization of a cache
        type: enum
        constraints: unspecified
- prompting_technique: zero_shot3
  prompt: '

    RISC-V is an Open Standard Instruction Set Architecture (ISA).

    To put it simply, an ISA is the language that a computer''s hardware speaks. It
    defines the set of instructions (like add, subtract, load, or store) that a processor
    can execute.


    Architectural Parameters are the variables of a hardware design. They are the
    specific values or behaviors that the hardware designer must decide on and the
    software must account for.


    There are two main types of parameters:

    Fixed Parameters (Standard): These are defined by the ISA and cannot be changed.

    Implementation-Specific Parameters: The ISA says these must exist, but the chip
    designer chooses the value.


    You are a expert in RISC-V.


    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words usually implies a parameter so put extra focus on
    them:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific

    but it maybe that the above words are not present but a parameter is defined.


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write unspecified


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 2.1:

    "Conventional" R/W accessibility of CSRs according to address mapping

    The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
    to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
    are used to encode the read and write accessibility of the CSRs according to privilege
    level as shown in Table 1. The top two bits (csr[11:10]) indicate whether the
    register is read/write (00,01, or 10) or read-only (11). The next two bits (csr[9:8])
    encode the lowest privilege level that can access the CSR.


    '
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr[11:10]
        description: Indicates whether the register is read/write or read-only.
        type: enum
        constraints: 00, 01, 10, 11
      - name: csr[9:8]
        description: Encodes the lowest privilege level that can access the CSR.
        type: bitfield
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr[11:8]
        description: Upper 4 bits of the CSR address
        type: enum
        constraints: Table 1
      - name: csr[9:8]
        description: Lowest privilege level that can access the CSR
        type: enum
        constraints: Table 1
- prompting_technique: zero_shot4
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make, which influence architectural behavior and must be tolerated by software.\n\
    These parameters arise where the ISA allows implementation freedom rather than\
    \ mandating one behavior.\nTypical cases include:\n\u2022 Implementation-defined\
    \ sizes or limits\n\u2022 Optional features\n\u2022 Implementation-dependent behavior\n\
    \u2022 WARL CSR field legal value ranges and mappings\nParameters are generally\
    \ not directly controlled by software-visible architectural state, but are properties\
    \ of the implementation.\n\nYou are an expert hardware designer with years of\
    \ experience in RISC-V.\n\nTask:\nYou will be given excerpts from RISC-V Instruction\
    \ Set Manual (RISC-V ISA) and have to extract architectural parameters from them.\n\
    The usage of following words usually implies a parameter so put extra focus on\
    \ them:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific\nbut it maybe that the above words are not present but a parameter\
    \ is defined.\n\nRules:\n- Do NOT infer unstated behavior\n- Do NOT describe the\
    \ schema\n- Output ONLY data\n- If no constraint is given, write unspecified\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 19.3.1:\nCaches organize copies of data into cache blocks, each\
    \ of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity and organization of a cache vary between implementations.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific, but it
          is uniform throughout the system in the initial set of CMO extensions.
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: Size of a cache block
        type: implementation_specific
        constraints: unspecified
      - name: cache_capacity
        description: Capacity of a cache
        type: implementation_specific
        constraints: unspecified
      - name: cache_organization
        description: Organization of a cache
        type: implementation_specific
        constraints: unspecified
- prompting_technique: zero_shot4
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make, which influence architectural behavior and must be tolerated by software.\n\
    These parameters arise where the ISA allows implementation freedom rather than\
    \ mandating one behavior.\nTypical cases include:\n\u2022 Implementation-defined\
    \ sizes or limits\n\u2022 Optional features\n\u2022 Implementation-dependent behavior\n\
    \u2022 WARL CSR field legal value ranges and mappings\nParameters are generally\
    \ not directly controlled by software-visible architectural state, but are properties\
    \ of the implementation.\n\nYou are an expert hardware designer with years of\
    \ experience in RISC-V.\n\nTask:\nYou will be given excerpts from RISC-V Instruction\
    \ Set Manual (RISC-V ISA) and have to extract architectural parameters from them.\n\
    The usage of following words usually implies a parameter so put extra focus on\
    \ them:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific\nbut it maybe that the above words are not present but a parameter\
    \ is defined.\n\nRules:\n- Do NOT infer unstated behavior\n- Do NOT describe the\
    \ schema\n- Output ONLY data\n- If no constraint is given, write unspecified\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to\
    \ address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: CSR Accessibility Encoding
        description: The encoding of CSR accessibility based on privilege levels,
          specifically the top two bits (csr[11:10]) indicating read/write or read-only
          status and the next two bits (csr[9:8]) indicating the lowest privilege
          level that can access the CSR.
        type: bitfield
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_accessibility_encoding_length
        description: Length of the CSR accessibility encoding space
        type: integer
        constraints: '12'
      - name: csr_address_mapping_convention
        description: Conventional CSR address mapping
        type: string
        constraints: unspecified
      - name: csr_address_mapping_upper_four_bits_usage
        description: Usage of the upper 4 bits of CSR address
        type: string
        constraints: unspecified
      - name: csr_accessibility_encoding_top_two_bits_usage
        description: Usage of the top two bits for CSR accessibility encoding
        type: string
        constraints: unspecified
      - name: csr_accessibility_encoding_next_two_bits_usage
        description: Usage of the next two bits for CSR accessibility encoding
        type: string
        constraints: unspecified
- prompting_technique: prompt_with_1ex
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make which influence architectural behavior and must be tolerated by software.\n\
    These parameters arise where the ISA allows implementation freedom rather than\
    \ mandating one behavior.\nTypical cases include:\n\u2022 Implementation-defined\
    \ sizes or limits\n\u2022 Optional features or behaviors\n\u2022 Implementation-dependent\
    \ behavior\n\u2022 WARL CSR field legal value ranges and illegal-to-legal mappings\n\
    \nParameters are not directly controlled by software-visible architectural state,\
    \ but are properties of the implementation.\nYou are an expert hardware designer\
    \ with years of experience in RISC-V.\n\nTask:\nYou will be given excerpts from\
    \ the RISC-V Instruction Set Manual and must extract architectural parameters\
    \ from them.\n\nThe usage of following words usually implies a parameter so put\
    \ extra focus on them:\nmay,might,should,\noptional,optionally,\nimplementation\
    \ defined,implementation specific,either, can.\n\nHowever, parameters may exist\
    \ even when these words are absent.\n\nRules:\n- Extract only implementation-defined\
    \ choices affecting architectural behavior.\n- Do NOT infer unstated behavior.\n\
    - Do NOT extract mechanisms provided to software (such as discovery interfaces).\n\
    - Do NOT describe the schema.\n- Output ONLY data.\n- If no constraint is given,\
    \ write unspecified.\n- Extract a parameter only if different implementations\
    \ may behave differently because of it.\n\nExamples:\n- name: means to discover\
    \ cache information\n  description: A means provided by the execution environment\
    \ to discover information about caches and cache blocks\n  type: string\n  constraints:\
    \ unspecified\nThis is a negative example. It is a software mechanism, not an\
    \ implementation parameter.\n\nname: cache_capacity\ndescription: The capacity\
    \ of a cache is implementation-specific.\ntype: integer\nconstraints: unspecified\n\
    This is a positive example since the capacity is implementation-specific and decided\
    \ by the hardware designer.\n\nInstructions on how to format the output:\nThe\
    \ output should be formatted as a JSON instance that conforms to the JSON schema\
    \ below.\n\nAs an example, for the schema {\"properties\": {\"foo\": {\"title\"\
    : \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\"\
    : {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"\
    bar\", \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\"\
    : {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\nHere is the output\
    \ schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\": {\"name\": {\"description\"\
    : \"Concise parameter name given in the specification or derived from the description\"\
    , \"title\": \"Name\", \"type\": \"string\"}, \"description\": {\"description\"\
    : \"Description derived strictly from the specification explaining what behavior\
    \ or capability varies due to this implementation-defined parameter\", \"title\"\
    : \"Description\", \"type\": \"string\"}, \"type\": {\"description\": \"type of\
    \ values the parameter takes : integer | boolean | enum | bitfield | range | structural\"\
    , \"title\": \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\"\
    : \"Explicit constraints on the values that the parameter can take or 'unspecified'\"\
    , \"title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\"\
    , \"description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nIf the specification refers to external tables or sections for constraints,\
    \ write constraints as unspecified.\n\nExcerpt from RISC-V (extract parameters\
    \ from the following text):\nPrivileged Spec 19.3.1:\nCaches organize copies of\
    \ data into cache blocks, each of which represents a contiguous, naturally aligned\
    \ power-of-two (or NAPOT) range of memory locations. A cache block is identified\
    \ by any of the physical addresses corresponding to the underlying memory locations.\
    \ The capacity and organization of a cache and the size of a cache block are both\
    \ implementation-specific, and the execution environment provides software a means\
    \ to discover information about the caches and cache blocks in a system. In the\
    \ initial set of CMO extensions, the size of a cache block shall be uniform throughout\
    \ the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parse_error: true
      error: "Failed to parse ParameterList from completion [{\"name\": \"cache_capacity\"\
        , \"description\": \"The capacity of a cache is implementation-specific.\"\
        , \"type\": \"integer\", \"constraints\": \"unspecified\"}, {\"name\": \"\
        cache_block_size\", \"description\": \"The size of a cache block is implementation-specific,\
        \ though it shall be uniform throughout the system in the initial set of CMO\
        \ extensions.\", \"type\": \"integer\", \"constraints\": \"unspecified\"}].\
        \ Got: 1 validation error for ParameterList\n  Input should be a valid dictionary\
        \ or instance of ParameterList [type=model_type, input_value=[{'name': 'cache_capacity...raints':\
        \ 'unspecified'}], input_type=list]\n    For further information visit https://errors.pydantic.dev/2.12/v/model_type\n\
        For troubleshooting, visit: https://docs.langchain.com/oss/python/langchain/errors/OUTPUT_PARSING_FAILURE "
      raw_output: "```json\n[\n    {\n        \"name\": \"cache_capacity\",\n    \
        \    \"description\": \"The capacity of a cache is implementation-specific.\"\
        ,\n        \"type\": \"integer\",\n        \"constraints\": \"unspecified\"\
        \n    },\n    {\n        \"name\": \"cache_block_size\",\n        \"description\"\
        : \"The size of a cache block is implementation-specific, though it shall\
        \ be uniform throughout the system in the initial set of CMO extensions.\"\
        ,\n        \"type\": \"integer\",\n        \"constraints\": \"unspecified\"\
        \n    }\n]\n```"
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parse_error: true
      error: "Failed to parse ParameterList from completion {\"parameters\": [\"cache_capacity\"\
        , \"cache_block_size\", \"cache_organization\"]}. Got: 3 validation errors\
        \ for ParameterList\nparameters.0\n  Input should be a valid dictionary or\
        \ instance of Parameter [type=model_type, input_value='cache_capacity', input_type=str]\n\
        \    For further information visit https://errors.pydantic.dev/2.12/v/model_type\n\
        parameters.1\n  Input should be a valid dictionary or instance of Parameter\
        \ [type=model_type, input_value='cache_block_size', input_type=str]\n    For\
        \ further information visit https://errors.pydantic.dev/2.12/v/model_type\n\
        parameters.2\n  Input should be a valid dictionary or instance of Parameter\
        \ [type=model_type, input_value='cache_organization', input_type=str]\n  \
        \  For further information visit https://errors.pydantic.dev/2.12/v/model_type\n\
        For troubleshooting, visit: https://docs.langchain.com/oss/python/langchain/errors/OUTPUT_PARSING_FAILURE "
      raw_output: '{"parameters": ["cache_capacity", "cache_block_size", "cache_organization"]}'
- prompting_technique: prompt_with_1ex
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make which influence architectural behavior and must be tolerated by software.\n\
    These parameters arise where the ISA allows implementation freedom rather than\
    \ mandating one behavior.\nTypical cases include:\n\u2022 Implementation-defined\
    \ sizes or limits\n\u2022 Optional features or behaviors\n\u2022 Implementation-dependent\
    \ behavior\n\u2022 WARL CSR field legal value ranges and illegal-to-legal mappings\n\
    \nParameters are not directly controlled by software-visible architectural state,\
    \ but are properties of the implementation.\nYou are an expert hardware designer\
    \ with years of experience in RISC-V.\n\nTask:\nYou will be given excerpts from\
    \ the RISC-V Instruction Set Manual and must extract architectural parameters\
    \ from them.\n\nThe usage of following words usually implies a parameter so put\
    \ extra focus on them:\nmay,might,should,\noptional,optionally,\nimplementation\
    \ defined,implementation specific,either, can.\n\nHowever, parameters may exist\
    \ even when these words are absent.\n\nRules:\n- Extract only implementation-defined\
    \ choices affecting architectural behavior.\n- Do NOT infer unstated behavior.\n\
    - Do NOT extract mechanisms provided to software (such as discovery interfaces).\n\
    - Do NOT describe the schema.\n- Output ONLY data.\n- If no constraint is given,\
    \ write unspecified.\n- Extract a parameter only if different implementations\
    \ may behave differently because of it.\n\nExamples:\n- name: means to discover\
    \ cache information\n  description: A means provided by the execution environment\
    \ to discover information about caches and cache blocks\n  type: string\n  constraints:\
    \ unspecified\nThis is a negative example. It is a software mechanism, not an\
    \ implementation parameter.\n\nname: cache_capacity\ndescription: The capacity\
    \ of a cache is implementation-specific.\ntype: integer\nconstraints: unspecified\n\
    This is a positive example since the capacity is implementation-specific and decided\
    \ by the hardware designer.\n\nInstructions on how to format the output:\nThe\
    \ output should be formatted as a JSON instance that conforms to the JSON schema\
    \ below.\n\nAs an example, for the schema {\"properties\": {\"foo\": {\"title\"\
    : \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\"\
    : {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"\
    bar\", \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\"\
    : {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\nHere is the output\
    \ schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\": {\"name\": {\"description\"\
    : \"Concise parameter name given in the specification or derived from the description\"\
    , \"title\": \"Name\", \"type\": \"string\"}, \"description\": {\"description\"\
    : \"Description derived strictly from the specification explaining what behavior\
    \ or capability varies due to this implementation-defined parameter\", \"title\"\
    : \"Description\", \"type\": \"string\"}, \"type\": {\"description\": \"type of\
    \ values the parameter takes : integer | boolean | enum | bitfield | range | structural\"\
    , \"title\": \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\"\
    : \"Explicit constraints on the values that the parameter can take or 'unspecified'\"\
    , \"title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\"\
    , \"description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nIf the specification refers to external tables or sections for constraints,\
    \ write constraints as unspecified.\n\nExcerpt from RISC-V (extract parameters\
    \ from the following text):\nPrivileged Spec 2.1:\n\"Conventional\" R/W accessibility\
    \ of CSRs according to address mapping\nThe standard RISC-V ISA sets aside a 12-bit\
    \ encoding space (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4\
    \ bits of the CSR address (csr[11:8]) are used to encode the read and write accessibility\
    \ of the CSRs according to privilege level as shown in Table 1. The top two bits\
    \ (csr[11:10]) indicate whether the register is read/write (00,01, or 10) or read-only\
    \ (11). The next two bits (csr[9:8]) encode the lowest privilege level that can\
    \ access the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_accessibility
        description: The read and write accessibility of CSRs according to privilege
          level, encoded in csr[11:8] and csr[11:10].
        type: bitfield
        constraints: unspecified
      - name: lowest_privilege_level
        description: The lowest privilege level that can access the CSR, encoded in
          csr[9:8].
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_address_mapping
        description: Mapping of CSR addresses to accessibility
        type: unspecified
        constraints: unspecified
      - name: csr_accessibility_encoding
        description: Encoding of read and write accessibility of CSRs according to
          privilege level
        type: unspecified
        constraints: unspecified
      - name: csr_privilege_levels
        description: Privilege levels that can access a CSR
        type: enum
        constraints: unspecified
- prompting_technique: prompt6
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make which influence architectural behavior and must be tolerated by software.\n\
    Typical cases include:\n\u2022 Implementation-defined sizes or limits\n\u2022\
    \ Optional features or behaviors\n\u2022 Implementation-dependent behavior\n\u2022\
    \ WARL CSR field legal value ranges and illegal-to-legal mappings\n\nParameters\
    \ are not directly controlled by software-visible architectural state, but are\
    \ properties of the implementation.\nYou are an expert hardware designer with\
    \ years of experience in RISC-V.\n\nTask:\nYou will be given excerpts from the\
    \ RISC-V Instruction Set Manual and must extract architectural parameters from\
    \ them.\n\nThe usage of following words usually implies a parameter so pay special\
    \ attention on them:\nmay,might,should,\noptional,optionally,\nimplementation\
    \ defined,implementation specific,either, can.\n\nHowever, parameters may exist\
    \ even when these words are absent.\n\nRules:\n- Do NOT infer unstated behavior.\n\
    - Do NOT describe the schema.\n- If constraint refers to external source write\
    \ unspecified.\n\nExamples:\n- name: means to discover cache information\n  description:\
    \ A means provided by the execution environment to discover information about\
    \ caches and cache blocks\n  type: string\n  constraints: unspecified\nThis is\
    \ a negative example. It is a software mechanism, not an implementation parameter.\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V:\nPrivileged Spec 19.3.1:\nCaches organize copies\
    \ of data into cache blocks, each of which represents a contiguous, naturally\
    \ aligned power-of-two (or NAPOT) range of memory locations. A cache block is\
    \ identified by any of the physical addresses corresponding to the underlying\
    \ memory locations. The capacity and organization of a cache and the size of a\
    \ cache block are both implementation-specific, and the execution environment\
    \ provides software a means to discover information about the caches and cache\
    \ blocks in a system. In the initial set of CMO extensions, the size of a cache\
    \ block shall be uniform throughout the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity_and_organization
        description: The capacity and organization of a cache are implementation-specific
          and vary between different implementations.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific and can
          vary, though it must be uniform across the system in the initial set of
          CMO extensions.
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: Cache block size
        description: The size of a cache block is implementation-specific and the
          same throughout the system in the initial set of CMO extensions.
        type: range
        constraints: unspecified
      - name: Cache capacity
        description: The capacity of a cache is implementation-specific.
        type: range
        constraints: unspecified
      - name: Cache organization
        description: The organization of a cache is implementation-specific.
        type: enum
        constraints: unspecified
- prompting_technique: prompt6
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make which influence architectural behavior and must be tolerated by software.\n\
    Typical cases include:\n\u2022 Implementation-defined sizes or limits\n\u2022\
    \ Optional features or behaviors\n\u2022 Implementation-dependent behavior\n\u2022\
    \ WARL CSR field legal value ranges and illegal-to-legal mappings\n\nParameters\
    \ are not directly controlled by software-visible architectural state, but are\
    \ properties of the implementation.\nYou are an expert hardware designer with\
    \ years of experience in RISC-V.\n\nTask:\nYou will be given excerpts from the\
    \ RISC-V Instruction Set Manual and must extract architectural parameters from\
    \ them.\n\nThe usage of following words usually implies a parameter so pay special\
    \ attention on them:\nmay,might,should,\noptional,optionally,\nimplementation\
    \ defined,implementation specific,either, can.\n\nHowever, parameters may exist\
    \ even when these words are absent.\n\nRules:\n- Do NOT infer unstated behavior.\n\
    - Do NOT describe the schema.\n- If constraint refers to external source write\
    \ unspecified.\n\nExamples:\n- name: means to discover cache information\n  description:\
    \ A means provided by the execution environment to discover information about\
    \ caches and cache blocks\n  type: string\n  constraints: unspecified\nThis is\
    \ a negative example. It is a software mechanism, not an implementation parameter.\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V:\nPrivileged Spec 2.1:\n\"Conventional\" R/W\
    \ accessibility of CSRs according to address mapping\nThe standard RISC-V ISA\
    \ sets aside a 12-bit encoding space (csr[11:0]) for up to 4,096 CSRs. By convention,\
    \ the upper 4 bits of the CSR address (csr[11:8]) are used to encode the read\
    \ and write accessibility of the CSRs according to privilege level as shown in\
    \ Table 1. The top two bits (csr[11:10]) indicate whether the register is read/write\
    \ (00,01, or 10) or read-only (11). The next two bits (csr[9:8]) encode the lowest\
    \ privilege level that can access the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: CSR Accessibility Mapping
        description: The read and write accessibility of CSRs according to the privilege
          level is determined by the implementation-specific encoding of the CSR addresses.
        type: structural
        constraints: unspecified
      - name: CSR Read/Write Access
        description: The read/write access of CSRs is determined by the top two bits
          (csr[11:10]) of the CSR address.
        type: bitfield
        constraints: unspecified
      - name: Lowest Privilege Level Access
        description: The lowest privilege level that can access a CSR is encoded in
          csr[9:8].
        type: bitfield
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_encoding_space
        description: 12-bit encoding space for up to 4,096 CSRs
        type: integer
        constraints: unspecified
      - name: csr[11:10]
        description: Bits indicating read and write accessibility of CSRs
        type: enum
        constraints: '[00, 01, 10, 11]'
      - name: csr[9:8]
        description: Bits encoding the lowest privilege level that can access the
          CSR
        type: enum
        constraints: '[00, 01, 10, 11]'
- prompting_technique: prompt7
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\n\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific\nHowever,\
    \ parameters may exist even when these words are absent.\n\nRules:\n- Do NOT infer\
    \ unstated behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ write unspecified.\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\nInstructions on how to format the output:\nThe output should be\
    \ formatted as a JSON instance that conforms to the JSON schema below.\n\nAs an\
    \ example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\"\
    : \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 19.3.1:\nCaches organize copies of data into cache blocks, each\
    \ of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The total capacity of a cache is implementation-specific.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache is implementation-specific.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific and shall
          be uniform throughout the system.
        type: integer
        constraints: shall be uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: size of a cache block
        type: unspecified
        constraints: implementation-specific
      - name: cache_capacity
        description: capacity of a cache
        type: unspecified
        constraints: implementation-specific
      - name: cache_organization
        description: organization of a cache
        type: unspecified
        constraints: implementation-specific
- prompting_technique: prompt7
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\n\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific\nHowever,\
    \ parameters may exist even when these words are absent.\n\nRules:\n- Do NOT infer\
    \ unstated behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ write unspecified.\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\nInstructions on how to format the output:\nThe output should be\
    \ formatted as a JSON instance that conforms to the JSON schema below.\n\nAs an\
    \ example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\"\
    : \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to\
    \ address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: CSR Accessibility
        description: Indicates the read/write accessibility of CSRs according to privilege
          level based on the csr[11:10] bits.
        type: enum
        constraints: unspecified
      - name: Minimum Privilege Level Access
        description: Encodes the lowest privilege level that can access the CSR based
          on the csr[9:8] bits.
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr[11:10]
        description: indicates whether the register is read/write (00,01, or 10) or
          read-only (11)
        type: enum
        constraints: unspecified
      - name: csr[9:8]
        description: encodes the lowest privilege level that can access the CSR
        type: enum
        constraints: unspecified
      - name: csr[11:8]
        description: encode the read and write accessibility of the CSRs according
          to privilege level
        type: bitfield
        constraints: unspecified
- prompting_technique: prompt8
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard that we have to follow it giving us no choice\
    \ it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\nYou will be given\
    \ excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and have to extract\
    \ architectural parameters from them.\nThe usage of following words usually implies\
    \ a parameter so put extra focus on them:\nmay/might/should,\noptional/optionally,\n\
    implementation defined/implementation specific,\ncan/either\nHowever, parameters\
    \ may exist even when these words are absent.\n\nRules:\n- Do NOT infer unstated\
    \ behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no constraint\
    \ is given, write unspecified\n- If constraint refers to external source write\
    \ unspecified.\n\nExamples:\n- name: means to discover cache information\n  description:\
    \ A means provided by the execution environment to discover information about\
    \ caches and cache blocks\n  type: string\n  constraints: unspecified\nThis is\
    \ a negative example. It is a software mechanism, not an implementation parameter.\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 19.3.1:\nCaches organize copies of data into cache blocks, each\
    \ of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The total capacity of a cache, which varies based on the implementation.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache, which varies based on the implementation.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block, which is uniform throughout the system
          according to the initial set of CMO extensions.
        type: integer
        constraints: uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: The size of a cache block
        type: unspecified
        constraints: implementation-specific
      - name: cache_capacity
        description: The capacity of a cache
        type: unspecified
        constraints: implementation-specific
      - name: cache_organization
        description: The organization of a cache
        type: unspecified
        constraints: implementation-specific
- prompting_technique: prompt8
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard that we have to follow it giving us no choice\
    \ it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\nYou will be given\
    \ excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and have to extract\
    \ architectural parameters from them.\nThe usage of following words usually implies\
    \ a parameter so put extra focus on them:\nmay/might/should,\noptional/optionally,\n\
    implementation defined/implementation specific,\ncan/either\nHowever, parameters\
    \ may exist even when these words are absent.\n\nRules:\n- Do NOT infer unstated\
    \ behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no constraint\
    \ is given, write unspecified\n- If constraint refers to external source write\
    \ unspecified.\n\nExamples:\n- name: means to discover cache information\n  description:\
    \ A means provided by the execution environment to discover information about\
    \ caches and cache blocks\n  type: string\n  constraints: unspecified\nThis is\
    \ a negative example. It is a software mechanism, not an implementation parameter.\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to\
    \ address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: CSR Accessibility
        description: Indicates the read and write accessibility of CSRs according
          to privilege level.
        type: enum
        constraints: unspecified
      - name: Minimum Privilege Level for CSR Access
        description: Encodes the lowest privilege level that can access the CSR.
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr[11:8] encoding
        description: The upper 4 bits of the CSR address used to encode the read and
          write accessibility of the CSRs
        type: enum
        constraints: unspecified
      - name: csr[11:10] encoding
        description: The top two bits of the CSR address indicating whether the register
          is read/write or read-only
        type: enum
        constraints: unspecified
      - name: csr[9:8] encoding
        description: The next two bits of the CSR address encoding the lowest privilege
          level that can access the CSR
        type: enum
        constraints: unspecified
- prompting_technique: prompt9
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every exercpt will contain parameters.\n\nRules:\n- Do NOT infer\
    \ unstated behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ write unspecified.\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\n name: cache_capacity\n description: The capacity of a cache,\
    \ which may affect the number of cache\n blocks it can store.\n type: range\n\
    \ constraints: unspecified\n name: cache_organization\n description: The organization\
    \ of a cache, including the arrangement of cache\n blocks and their corresponding\
    \ tags.\n type: enum\n constraints: unspecified\n These are positive examples\
    \ as changes in them affect the processor behavior and they dont have any previously\
    \ defined standard value.\n\nInstructions on how to format the output:\nThe output\
    \ should be formatted as a JSON instance that conforms to the JSON schema below.\n\
    \nAs an example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\"\
    , \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"\
    type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\"\
    , \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\"\
    : {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\nHere is the output\
    \ schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\": {\"name\": {\"description\"\
    : \"Concise parameter name given in the specification or derived from the description\"\
    , \"title\": \"Name\", \"type\": \"string\"}, \"description\": {\"description\"\
    : \"Description derived strictly from the specification explaining what behavior\
    \ or capability varies due to this implementation-defined parameter\", \"title\"\
    : \"Description\", \"type\": \"string\"}, \"type\": {\"description\": \"type of\
    \ values the parameter takes : integer | boolean | enum | bitfield | range | structural\"\
    , \"title\": \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\"\
    : \"Explicit constraints on the values that the parameter can take or 'unspecified'\"\
    , \"title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\"\
    , \"description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 19.3.1:\nCaches organize copies of data into cache blocks, each\
    \ of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache, which may affect the number of cache
          blocks it can store.
        type: range
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache, including the arrangement of cache
          blocks and their corresponding tags.
        type: enum
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block, which is uniform throughout the system
          in the initial set of CMO extensions.
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache
        type: range
        constraints: implementation-specific
      - name: cache_organization
        description: The organization of a cache
        type: range
        constraints: implementation-specific
      - name: cache_block_size
        description: The size of a cache block
        type: range
        constraints: implementation-specific
      - name: cache_block_alignment
        description: The size of a cache block should be a power-of-two (or NAPOT)
          range of memory locations
        type: range
        constraints: unspecified
- prompting_technique: prompt9
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every exercpt will contain parameters.\n\nRules:\n- Do NOT infer\
    \ unstated behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ write unspecified.\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\n name: cache_capacity\n description: The capacity of a cache,\
    \ which may affect the number of cache\n blocks it can store.\n type: range\n\
    \ constraints: unspecified\n name: cache_organization\n description: The organization\
    \ of a cache, including the arrangement of cache\n blocks and their corresponding\
    \ tags.\n type: enum\n constraints: unspecified\n These are positive examples\
    \ as changes in them affect the processor behavior and they dont have any previously\
    \ defined standard value.\n\nInstructions on how to format the output:\nThe output\
    \ should be formatted as a JSON instance that conforms to the JSON schema below.\n\
    \nAs an example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\"\
    , \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"\
    type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\"\
    , \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\"\
    : {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\nHere is the output\
    \ schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\": {\"name\": {\"description\"\
    : \"Concise parameter name given in the specification or derived from the description\"\
    , \"title\": \"Name\", \"type\": \"string\"}, \"description\": {\"description\"\
    : \"Description derived strictly from the specification explaining what behavior\
    \ or capability varies due to this implementation-defined parameter\", \"title\"\
    : \"Description\", \"type\": \"string\"}, \"type\": {\"description\": \"type of\
    \ values the parameter takes : integer | boolean | enum | bitfield | range | structural\"\
    , \"title\": \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\"\
    : \"Explicit constraints on the values that the parameter can take or 'unspecified'\"\
    , \"title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\"\
    , \"description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to\
    \ address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_read_write_accessibility
        description: The top two bits (csr[11:10]) indicate whether the register is
          read/write (00,01, or 10) or read-only (11)
        type: enum
        constraints: unspecified
      - name: lowest_privilege_level_access
        description: The next two bits (csr[9:8]) encode the lowest privilege level
          that can access the CSR
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_accessibility_encoding
        description: Conventional encoding of read and write accessibility of CSRs
          according to privilege level
        type: enum
        constraints: Table 1
      - name: csr_address_mapping
        description: Address mapping of CSRs
        type: unspecified
        constraints: unspecified
      - name: csr_privilege_level_encoding
        description: Encoding of privilege level that can access the CSR
        type: enum
        constraints: csr[9:8]
      - name: csr_privilege_level
        description: Privilege level that can access the CSR
        type: unspecified
        constraints: unspecified
- prompting_technique: prompt10
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every exercpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER infer\
    \ unstated behavior\n- NEVER describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ NEVER WRITE IT INSTEAD WRITE unspecified.\n\nReasoning Process (Think Step-by-Step):\n\
    For every potential parameter, ask:\n1. Is this a fixed rule I must follow to\
    \ be RISC-V Compliant? (If yes, discard).\n2. Is this a field labeled WARL (Write\
    \ Any values, Reads Legal values)? (If yes, it is a parameter for legal values\
    \ and mapping).\n3. Does the text allow for different 'BEHAVIOUR' or 'VALUES'\
    \ across different chips? (If yes, extract the choice).\n4. Once choice is extracted\
    \ check if the spec specifies a type or constraint on its values.(REFER TO RULES\
    \ AND FORMAT INSTRUCTIONS).\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\n name: cache_capacity\n description: The capacity of a cache,\
    \ which may affect the number of cache\n blocks it can store.\n type: range\n\
    \ constraints: unspecified\n This is a positive examples as changes in them affect\
    \ the processor behavior and they dont have any previously defined standard value.\n\
    \n\nExcerpt from RISC-V(extract parameters from the following text):\nPrivileged\
    \ Spec 19.3.1:\nCaches organize copies of data into cache blocks, each of which\
    \ represents a contiguous, naturally aligned power-of-two (or NAPOT) range of\
    \ memory locations. A cache block is identified by any of the physical addresses\
    \ corresponding to the underlying memory locations. The capacity and organization\
    \ of a cache and the size of a cache block are both implementation-specific, and\
    \ the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache, which affects the number of cache blocks
          it can store.
        type: range
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block, which is uniform throughout the system
          in the initial set of CMO extensions.
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: The size of a cache block
        type: range
        constraints: unspecified
      - name: cache_capacity
        description: The capacity of a cache
        type: range
        constraints: unspecified
      - name: implementation_specific_cache_organization
        description: The capacity and organization of a cache
        type: enum
        constraints: unspecified
- prompting_technique: prompt10
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every exercpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER infer\
    \ unstated behavior\n- NEVER describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ NEVER WRITE IT INSTEAD WRITE unspecified.\n\nReasoning Process (Think Step-by-Step):\n\
    For every potential parameter, ask:\n1. Is this a fixed rule I must follow to\
    \ be RISC-V Compliant? (If yes, discard).\n2. Is this a field labeled WARL (Write\
    \ Any values, Reads Legal values)? (If yes, it is a parameter for legal values\
    \ and mapping).\n3. Does the text allow for different 'BEHAVIOUR' or 'VALUES'\
    \ across different chips? (If yes, extract the choice).\n4. Once choice is extracted\
    \ check if the spec specifies a type or constraint on its values.(REFER TO RULES\
    \ AND FORMAT INSTRUCTIONS).\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\n name: cache_capacity\n description: The capacity of a cache,\
    \ which may affect the number of cache\n blocks it can store.\n type: range\n\
    \ constraints: unspecified\n This is a positive examples as changes in them affect\
    \ the processor behavior and they dont have any previously defined standard value.\n\
    \n\nExcerpt from RISC-V(extract parameters from the following text):\nPrivileged\
    \ Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to address mapping\n\
    The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up\
    \ to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])\
    \ are used to encode the read and write accessibility of the CSRs according to\
    \ privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate\
    \ whether the register is read/write (00,01, or 10) or read-only (11). The next\
    \ two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.\n\
    \n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_accessibility
        description: The read and write accessibility of the CSRs according to privilege
          level, encoded in csr[11:8] and csr[11:10].
        type: enum
        constraints: unspecified
      - name: lowest_privilege_level
        description: The lowest privilege level that can access the CSR, encoded in
          csr[9:8].
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr[11:8]
        description: Conventional accessibility encoding of CSRs according to privilege
          level
        type: enum
        constraints: unspecified
      - name: csr[11:10]
        description: Conventional accessibility encoding of CSRs according to privilege
          level
        type: enum
        constraints: unspecified
      - name: csr[9:8]
        description: Conventional accessibility encoding of CSRs according to privilege
          level
        type: enum
        constraints: unspecified
- prompting_technique: prompt11
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every excerpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER describe\
    \ the schema.\n- If constraint refers to external source NEVER WRITE IT; INSTEAD\
    \ WRITE unspecified.\n- Output ONLY data.\n\nReasoning Process (Think Step-by-Step):\n\
    1. Is this a fixed rule or address mapping set by the ISA? Even if it is called\
    \ a 'convention', if it must be followed for standard compliance, DISCARD it.\n\
    2. Is this a field labeled WARL (Write Any values, Reads Legal values)? If yes,\
    \ it is ALWAYS a parameter for legal values and mapping behavior.\n3. Does the\
    \ text allow for different 'BEHAVIOUR' or 'VALUES' across different chips? If\
    \ the hardware designer has a choice between A or B, EXTRACT it.\n4. Once a choice\
    \ is extracted, check if the spec specifies a type or constraint on its values.\n\
    \nExamples:\n- Text: 'By convention, the red light is always located at the top\
    \ of the traffic signal and indicates that the vehicle must stop.'\n  Reasoning:\
    \ This is a fixed standard ('By convention') required for the system to work.\
    \ A manufacturer cannot choose to put the red light at the bottom and remain compliant.\n\
    \  Result: 'parameters: []'\n  (This is a negative example: showing what NOT to\
    \ extract).\n\n- Text: 'The horsepower and fuel-tank capacity of an engine and\
    \ the material of the seats are all manufacturer-specific.'\n  Reasoning: The\
    \ phrase 'manufacturer-specific' indicates these are choices the builder makes.\
    \ Different versions of the car will have different values.\n  Output:\n  - name:\
    \ engine_horsepower\n    description: The power output of the engine as determined\
    \ by the manufacturer.\n    type: range\n    constraints: manufacturer-specific\n\
    \  - name: fuel_tank_capacity\n    description: The total volume of fuel the vehicle\
    \ can store.\n    type: range\n    constraints: manufacturer-specific\n  - name:\
    \ seat_material\n    description: The type of material used for the interior upholstery.\n\
    \    type: enum\n    constraints: manufacturer-specific\n  This is a positive\
    \ example.\n\nExcerpt from RISC-V (extract parameters from the following text):\n\
    Privileged Spec 19.3.1:\nCaches organize copies of data into cache blocks, each\
    \ of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The total capacity of a cache, which can vary across implementations.
        type: range
        constraints: unspecified
      - name: cache_organization
        description: The organization structure of a cache, which can vary across
          implementations.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block, which is uniform throughout the system
          according to the initial set of CMO extensions but can vary in future implementations.
        type: range
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: The size of a cache block.
        type: range
        constraints: implementation-specific
      - name: cache_capacity
        description: The capacity of a cache.
        type: range
        constraints: implementation-specific
      - name: cache_organization
        description: The organization of a cache.
        type: enum
        constraints: implementation-specific
- prompting_technique: prompt11
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every excerpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER describe\
    \ the schema.\n- If constraint refers to external source NEVER WRITE IT; INSTEAD\
    \ WRITE unspecified.\n- Output ONLY data.\n\nReasoning Process (Think Step-by-Step):\n\
    1. Is this a fixed rule or address mapping set by the ISA? Even if it is called\
    \ a 'convention', if it must be followed for standard compliance, DISCARD it.\n\
    2. Is this a field labeled WARL (Write Any values, Reads Legal values)? If yes,\
    \ it is ALWAYS a parameter for legal values and mapping behavior.\n3. Does the\
    \ text allow for different 'BEHAVIOUR' or 'VALUES' across different chips? If\
    \ the hardware designer has a choice between A or B, EXTRACT it.\n4. Once a choice\
    \ is extracted, check if the spec specifies a type or constraint on its values.\n\
    \nExamples:\n- Text: 'By convention, the red light is always located at the top\
    \ of the traffic signal and indicates that the vehicle must stop.'\n  Reasoning:\
    \ This is a fixed standard ('By convention') required for the system to work.\
    \ A manufacturer cannot choose to put the red light at the bottom and remain compliant.\n\
    \  Result: 'parameters: []'\n  (This is a negative example: showing what NOT to\
    \ extract).\n\n- Text: 'The horsepower and fuel-tank capacity of an engine and\
    \ the material of the seats are all manufacturer-specific.'\n  Reasoning: The\
    \ phrase 'manufacturer-specific' indicates these are choices the builder makes.\
    \ Different versions of the car will have different values.\n  Output:\n  - name:\
    \ engine_horsepower\n    description: The power output of the engine as determined\
    \ by the manufacturer.\n    type: range\n    constraints: manufacturer-specific\n\
    \  - name: fuel_tank_capacity\n    description: The total volume of fuel the vehicle\
    \ can store.\n    type: range\n    constraints: manufacturer-specific\n  - name:\
    \ seat_material\n    description: The type of material used for the interior upholstery.\n\
    \    type: enum\n    constraints: manufacturer-specific\n  This is a positive\
    \ example.\n\nExcerpt from RISC-V (extract parameters from the following text):\n\
    Privileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to\
    \ address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_read_write_accessibility
        description: The top two bits (csr[11:10]) indicate whether the register is
          read/write (00, 01, or 10) or read-only (11).
        type: enum
        constraints: unspecified
      - name: lowest_privilege_level_accessibility
        description: The next two bits (csr[9:8]) encode the lowest privilege level
          that can access the CSR.
        type: bitfield
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_encoding
        description: The encoding of the CSR address
        type: bitfield
        constraints: unspecified
      - name: csr_read_write
        description: The read and write accessibility of the CSRs
        type: enum
        constraints: unspecified
      - name: csr_privilege_level
        description: The lowest privilege level that can access the CSR
        type: enum
        constraints: unspecified
- prompting_technique: prompt12
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every excerpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER describe\
    \ the schema.\n- If constraint refers to external source NEVER WRITE IT; INSTEAD\
    \ WRITE unspecified.\n- Output ONLY data.\n\nReasoning Process (Think Step-by-Step):\n\
    1. Is this a fixed rule or address mapping set by the ISA? Even if it is called\
    \ a 'convention', if it must be followed for standard compliance, DISCARD it.\n\
    2. Is this a field labeled WARL (Write Any values, Reads Legal values)? If yes,\
    \ it is ALWAYS a parameter for legal values and mapping behavior.\n3. Does the\
    \ text allow for different 'BEHAVIOUR' or 'VALUES' across different chips? If\
    \ the hardware designer has a choice between A or B, EXTRACT it.\n4. Once a choice\
    \ is extracted, check if the spec specifies a type or constraint on its values.\n\
    \nExamples:\n- Text: 'By convention, the red light is always located at the top\
    \ of the traffic signal and indicates that the vehicle must stop.'\n  Reasoning:\
    \ This is a fixed standard ('By convention') required for the system to work.\
    \ A manufacturer cannot choose to put the red light at the bottom and remain compliant.\n\
    \  Result: 'parameters: []'\n  (This is a negative example: showing what NOT to\
    \ extract).\n\n- Text: 'The horsepower and fuel-tank capacity of an engine and\
    \ the material of the seats are all manufacturer-specific.'\n  Reasoning: The\
    \ phrase 'manufacturer-specific' indicates these are choices the builder makes.\
    \ Different versions of the car will have different values.\n  Output:\n  - name:\
    \ engine_horsepower\n    description: The power output of the engine as determined\
    \ by the manufacturer.\n    type: range\n    constraints: manufacturer-specific\n\
    \  - name: fuel_tank_capacity\n    description: The total volume of fuel the vehicle\
    \ can store.\n    type: range\n    constraints: manufacturer-specific\n  - name:\
    \ seat_material\n    description: The type of material used for the interior upholstery.\n\
    \    type: enum\n    constraints: manufacturer-specific\n  This is a positive\
    \ example.\n\nExcerpt from RISC-V (extract parameters from the following text):\n\
    The mstatus register is a 64-bit read/write register. The MIE field (bit 3) and\
    \ the SIE field (bit 1) are used to enable interrupts in machine and supervisor\
    \ modes, respectively. The MPIE field (bit 7) holds the value of the interrupt-enable\
    \ bit prior to the trap.\n"
  input:
    text: The mstatus register is a 64-bit read/write register. The MIE field (bit
      3) and the SIE field (bit 1) are used to enable interrupts in machine and supervisor
      modes, respectively. The MPIE field (bit 7) holds the value of the interrupt-enable
      bit prior to the trap.
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters: []
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: mstatus_MIE
        description: Enable interrupts in machine mode
        type: boolean
        constraints: unspecified
      - name: mstatus_SIE
        description: Enable interrupts in supervisor mode
        type: boolean
        constraints: unspecified
      - name: mstatus_MPIE
        description: Hold the value of the interrupt-enable bit prior to the trap
        type: integer
        constraints: unspecified
- prompting_technique: prompt12
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every excerpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER describe\
    \ the schema.\n- If constraint refers to external source NEVER WRITE IT; INSTEAD\
    \ WRITE unspecified.\n- Output ONLY data.\n\nReasoning Process (Think Step-by-Step):\n\
    1. Is this a fixed rule or address mapping set by the ISA? Even if it is called\
    \ a 'convention', if it must be followed for standard compliance, DISCARD it.\n\
    2. Is this a field labeled WARL (Write Any values, Reads Legal values)? If yes,\
    \ it is ALWAYS a parameter for legal values and mapping behavior.\n3. Does the\
    \ text allow for different 'BEHAVIOUR' or 'VALUES' across different chips? If\
    \ the hardware designer has a choice between A or B, EXTRACT it.\n4. Once a choice\
    \ is extracted, check if the spec specifies a type or constraint on its values.\n\
    \nExamples:\n- Text: 'By convention, the red light is always located at the top\
    \ of the traffic signal and indicates that the vehicle must stop.'\n  Reasoning:\
    \ This is a fixed standard ('By convention') required for the system to work.\
    \ A manufacturer cannot choose to put the red light at the bottom and remain compliant.\n\
    \  Result: 'parameters: []'\n  (This is a negative example: showing what NOT to\
    \ extract).\n\n- Text: 'The horsepower and fuel-tank capacity of an engine and\
    \ the material of the seats are all manufacturer-specific.'\n  Reasoning: The\
    \ phrase 'manufacturer-specific' indicates these are choices the builder makes.\
    \ Different versions of the car will have different values.\n  Output:\n  - name:\
    \ engine_horsepower\n    description: The power output of the engine as determined\
    \ by the manufacturer.\n    type: range\n    constraints: manufacturer-specific\n\
    \  - name: fuel_tank_capacity\n    description: The total volume of fuel the vehicle\
    \ can store.\n    type: range\n    constraints: manufacturer-specific\n  - name:\
    \ seat_material\n    description: The type of material used for the interior upholstery.\n\
    \    type: enum\n    constraints: manufacturer-specific\n  This is a positive\
    \ example.\n\nExcerpt from RISC-V (extract parameters from the following text):\n\
    The MXR (Make Executable Readable) bit modifies the privilege of loads. When MXR=0,\
    \ only loads from pages marked readable will succeed. When MXR=1, loads from pages\
    \ marked either readable or executable will succeed. If supervisor-mode is not\
    \ supported, this bit is hardwired to 0.\n"
  input:
    text: The MXR (Make Executable Readable) bit modifies the privilege of loads.
      When MXR=0, only loads from pages marked readable will succeed. When MXR=1,
      loads from pages marked either readable or executable will succeed. If supervisor-mode
      is not supported, this bit is hardwired to 0.
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: MXR
        description: Determines whether loads from pages marked executable are allowed
          in addition to those marked readable.
        type: boolean
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: mxr
        description: The MXR bit modifies the privilege of loads.
        type: enum
        constraints: unspecified
      - name: supervisor_mode_supported
        description: Whether supervisor mode is supported by the implementation.
        type: boolean
        constraints: unspecified
- prompting_technique: prompt12
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every excerpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER describe\
    \ the schema.\n- If constraint refers to external source NEVER WRITE IT; INSTEAD\
    \ WRITE unspecified.\n- Output ONLY data.\n\nReasoning Process (Think Step-by-Step):\n\
    1. Is this a fixed rule or address mapping set by the ISA? Even if it is called\
    \ a 'convention', if it must be followed for standard compliance, DISCARD it.\n\
    2. Is this a field labeled WARL (Write Any values, Reads Legal values)? If yes,\
    \ it is ALWAYS a parameter for legal values and mapping behavior.\n3. Does the\
    \ text allow for different 'BEHAVIOUR' or 'VALUES' across different chips? If\
    \ the hardware designer has a choice between A or B, EXTRACT it.\n4. Once a choice\
    \ is extracted, check if the spec specifies a type or constraint on its values.\n\
    \nExamples:\n- Text: 'By convention, the red light is always located at the top\
    \ of the traffic signal and indicates that the vehicle must stop.'\n  Reasoning:\
    \ This is a fixed standard ('By convention') required for the system to work.\
    \ A manufacturer cannot choose to put the red light at the bottom and remain compliant.\n\
    \  Result: 'parameters: []'\n  (This is a negative example: showing what NOT to\
    \ extract).\n\n- Text: 'The horsepower and fuel-tank capacity of an engine and\
    \ the material of the seats are all manufacturer-specific.'\n  Reasoning: The\
    \ phrase 'manufacturer-specific' indicates these are choices the builder makes.\
    \ Different versions of the car will have different values.\n  Output:\n  - name:\
    \ engine_horsepower\n    description: The power output of the engine as determined\
    \ by the manufacturer.\n    type: range\n    constraints: manufacturer-specific\n\
    \  - name: fuel_tank_capacity\n    description: The total volume of fuel the vehicle\
    \ can store.\n    type: range\n    constraints: manufacturer-specific\n  - name:\
    \ seat_material\n    description: The type of material used for the interior upholstery.\n\
    \    type: enum\n    constraints: manufacturer-specific\n  This is a positive\
    \ example.\n\nExcerpt from RISC-V (extract parameters from the following text):\n\
    The mtvec register is a 64-bit RW register that holds trap vector configuration.\
    \ The BASE field (bits [63:2]) is a WARL field that must be aligned on a 4-byte\
    \ boundary. It is implementation-defined which subset of the 64-bit address space\
    \ can be represented by the BASE field.\n"
  input:
    text: The mtvec register is a 64-bit RW register that holds trap vector configuration.
      The BASE field (bits [63:2]) is a WARL field that must be aligned on a 4-byte
      boundary. It is implementation-defined which subset of the 64-bit address space
      can be represented by the BASE field.
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: mtvec_base_field
        description: The BASE field in the mtvec register which must be aligned on
          a 4-byte boundary and represents a subset of the 64-bit address space.
        type: bitfield
        constraints: implementation-defined
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: BASE field alignment
        description: The subset of the 64-bit address space that can be represented
          by the BASE field
        type: range
        constraints: unspecified
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words implies a parameter:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 19.3.1:

    Caches organize copies of data into cache blocks, each of which represents a contiguous,
    naturally aligned power-of-two (or NAPOT) range of memory locations. A cache block
    is identified by any of the physical addresses corresponding to the underlying
    memory locations. The capacity and organization of a cache and the size of a cache
    block are both implementation-specific, and the execution environment provides
    software a means to discover information about the caches and cache blocks in
    a system. In the initial set of CMO extensions, the size of a cache block shall
    be uniform throughout the system.


    '
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      error: You must provide an api_key to work with featherless-ai API or log in
        with `hf auth login`.
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      error: You must provide an api_key to work with novita API or log in with `hf
        auth login`.
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words implies a parameter:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 2.1:

    "Conventional" R/W accessibility of CSRs according to address mapping

    The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
    to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
    are used to encode the read and write accessibility of the CSRs according to privilege
    level as shown in Table 1. The top two bits (csr[11:10]) indicate whether the
    register is read/write (00,01, or 10) or read-only (11). The next two bits (csr[9:8])
    encode the lowest privilege level that can access the CSR.


    '
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      error: You must provide an api_key to work with featherless-ai API or log in
        with `hf auth login`.
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      error: You must provide an api_key to work with novita API or log in with `hf
        auth login`.
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words implies a parameter:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 19.3.1:

    Caches organize copies of data into cache blocks, each of which represents a contiguous,
    naturally aligned power-of-two (or NAPOT) range of memory locations. A cache block
    is identified by any of the physical addresses corresponding to the underlying
    memory locations. The capacity and organization of a cache and the size of a cache
    block are both implementation-specific, and the execution environment provides
    software a means to discover information about the caches and cache blocks in
    a system. In the initial set of CMO extensions, the size of a cache block shall
    be uniform throughout the system.


    '
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      error: You must provide an api_key to work with featherless-ai API or log in
        with `hf auth login`.
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      error: You must provide an api_key to work with novita API or log in with `hf
        auth login`.
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words implies a parameter:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 2.1:

    "Conventional" R/W accessibility of CSRs according to address mapping

    The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
    to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
    are used to encode the read and write accessibility of the CSRs according to privilege
    level as shown in Table 1. The top two bits (csr[11:10]) indicate whether the
    register is read/write (00,01, or 10) or read-only (11). The next two bits (csr[9:8])
    encode the lowest privilege level that can access the CSR.


    '
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      error: You must provide an api_key to work with featherless-ai API or log in
        with `hf auth login`.
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      error: You must provide an api_key to work with novita API or log in with `hf
        auth login`.
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words implies a parameter:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 19.3.1:

    Caches organize copies of data into cache blocks, each of which represents a contiguous,
    naturally aligned power-of-two (or NAPOT) range of memory locations. A cache block
    is identified by any of the physical addresses corresponding to the underlying
    memory locations. The capacity and organization of a cache and the size of a cache
    block are both implementation-specific, and the execution environment provides
    software a means to discover information about the caches and cache blocks in
    a system. In the initial set of CMO extensions, the size of a cache block shall
    be uniform throughout the system.


    '
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache is implementation-specific.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache is implementation-specific.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific but shall
          be uniform throughout the system in the initial set of CMO extensions.
        type: integer
        constraints: uniform in the initial set of CMO extensions
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: The size of a cache block.
        type: range
        constraints: implementation specific
      - name: cache_capacity
        description: The capacity of a cache.
        type: range
        constraints: implementation specific
      - name: cache_organization
        description: The organization of a cache.
        type: enum
        constraints: implementation specific
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words implies a parameter:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 2.1:

    "Conventional" R/W accessibility of CSRs according to address mapping

    The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
    to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
    are used to encode the read and write accessibility of the CSRs according to privilege
    level as shown in Table 1. The top two bits (csr[11:10]) indicate whether the
    register is read/write (00,01, or 10) or read-only (11). The next two bits (csr[9:8])
    encode the lowest privilege level that can access the CSR.


    '
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_accessibility
        description: Top two bits (csr[11:10]) indicate whether the register is read/write
          (00,01, or 10) or read-only (11)
        type: bitfield
        constraints: unspecified
      - name: lowest_privilege_level_access
        description: Next two bits (csr[9:8]) encode the lowest privilege level that
          can access the CSR
        type: bitfield
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr[11:10]
        description: Indicate whether the register is read/write or read-only
        type: enum
        constraints: 00=read/write, 01=read/write, 10=read/write, 11=read-only
      - name: csr[9:8]
        description: Encode the lowest privilege level that can access the CSR
        type: enum
        constraints: unspecified
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words usually implies a parameter so put extra focus on
    them:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific

    but it maybe that the above words are not present but a parameter is defined.


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 19.3.1:

    Caches organize copies of data into cache blocks, each of which represents a contiguous,
    naturally aligned power-of-two (or NAPOT) range of memory locations. A cache block
    is identified by any of the physical addresses corresponding to the underlying
    memory locations. The capacity and organization of a cache and the size of a cache
    block are both implementation-specific, and the execution environment provides
    software a means to discover information about the caches and cache blocks in
    a system. In the initial set of CMO extensions, the size of a cache block shall
    be uniform throughout the system.


    '
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: Capacity of a cache is implementation-specific.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: Organization of a cache is implementation-specific.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: Size of a cache block is implementation-specific, but shall be
          uniform throughout the system in the initial set of CMO extensions.
        type: integer
        constraints: uniform throughout the system in the initial set of CMO extensions
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: The size of a cache block.
        type: range
        constraints: implementation-specific
      - name: cache_capacity
        description: The capacity of a cache.
        type: range
        constraints: implementation-specific
      - name: cache_size
        description: The size of a cache.
        type: unspecified
        constraints: unspecified
- prompting_technique: zero_shot
  prompt: '

    You are a expert in RISC-V specifications.

    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words usually implies a parameter so put extra focus on
    them:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific

    but it maybe that the above words are not present but a parameter is defined.


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write "unspecified"


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 2.1:

    "Conventional" R/W accessibility of CSRs according to address mapping

    The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
    to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
    are used to encode the read and write accessibility of the CSRs according to privilege
    level as shown in Table 1. The top two bits (csr[11:10]) indicate whether the
    register is read/write (00,01, or 10) or read-only (11). The next two bits (csr[9:8])
    encode the lowest privilege level that can access the CSR.


    '
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr[11:10]
        description: Indicates whether the register is read/write (00,01, or 10) or
          read-only (11)
        type: enum
        constraints: 00,01,10,11
      - name: csr[9:8]
        description: Encodes the lowest privilege level that can access the CSR
        type: bitfield
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr[11:8]
        description: Upper 4 bits of the CSR address encoding privilege level
        type: enum
        constraints: unspecified
      - name: csr[11:10]
        description: Top two bits indicating read/write or read-only accessibility
        type: enum
        constraints: '{''00'': ''read/write'', ''01'': ''read/write'', ''10'': ''read/write'',
          ''11'': ''read-only''}'
      - name: csr[9:8]
        description: Lowest privilege level that can access the CSR
        type: enum
        constraints: unspecified
- prompting_technique: zero_shot3
  prompt: '

    RISC-V is an Open Standard Instruction Set Architecture (ISA).

    To put it simply, an ISA is the language that a computer''s hardware speaks. It
    defines the set of instructions (like add, subtract, load, or store) that a processor
    can execute.


    Architectural Parameters are the variables of a hardware design. They are the
    specific values or behaviors that the hardware designer must decide on and the
    software must account for.


    There are two main types of parameters:

    Fixed Parameters (Standard): These are defined by the ISA and cannot be changed.

    Implementation-Specific Parameters: The ISA says these must exist, but the chip
    designer chooses the value.


    You are a expert in RISC-V.


    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words usually implies a parameter so put extra focus on
    them:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific

    but it maybe that the above words are not present but a parameter is defined.


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write unspecified


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 19.3.1:

    Caches organize copies of data into cache blocks, each of which represents a contiguous,
    naturally aligned power-of-two (or NAPOT) range of memory locations. A cache block
    is identified by any of the physical addresses corresponding to the underlying
    memory locations. The capacity and organization of a cache and the size of a cache
    block are both implementation-specific, and the execution environment provides
    software a means to discover information about the caches and cache blocks in
    a system. In the initial set of CMO extensions, the size of a cache block shall
    be uniform throughout the system.


    '
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: Capacity of a cache
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: Organization of a cache
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: Size of a cache block
        type: integer
        constraints: shall be uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache capacity
        description: capacity of a cache
        type: unspecified
        constraints: implementation-specific
      - name: cache organization
        description: organization of a cache
        type: unspecified
        constraints: implementation-specific
      - name: cache block size
        description: size of a cache block
        type: unspecified
        constraints: implementation-defined, uniform throughout the system
- prompting_technique: zero_shot3
  prompt: '

    RISC-V is an Open Standard Instruction Set Architecture (ISA).

    To put it simply, an ISA is the language that a computer''s hardware speaks. It
    defines the set of instructions (like add, subtract, load, or store) that a processor
    can execute.


    Architectural Parameters are the variables of a hardware design. They are the
    specific values or behaviors that the hardware designer must decide on and the
    software must account for.


    There are two main types of parameters:

    Fixed Parameters (Standard): These are defined by the ISA and cannot be changed.

    Implementation-Specific Parameters: The ISA says these must exist, but the chip
    designer chooses the value.


    You are a expert in RISC-V.


    Task:

    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and
    have to extract architectural parameters from them.

    The usage of following words usually implies a parameter so put extra focus on
    them:

    may/might/should,

    optional/optionally,

    implementation defined/implementation specific

    but it maybe that the above words are not present but a parameter is defined.


    Rules:

    - Do NOT infer unstated behavior

    - Do NOT describe the schema

    - Output ONLY data

    - If no constraint is given, write unspecified


    Instructions on how to format the output:

    The output should be formatted as a JSON instance that conforms to the JSON schema
    below.


    As an example, for the schema {"properties": {"foo": {"title": "Foo", "description":
    "a list of strings", "type": "array", "items": {"type": "string"}}}, "required":
    ["foo"]}

    the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema.
    The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.


    Here is the output schema:

    ```

    {"$defs": {"Parameter": {"properties": {"name": {"description": "Concise parameter
    name given in the specification or derived from the description", "title": "Name",
    "type": "string"}, "description": {"description": "Description derived strictly
    from the specification", "title": "Description", "type": "string"}, "type": {"description":
    "type of values the parameter takes : integer | boolean | enum | bitfield | range
    | structural", "title": "Type", "type": "string"}, "constraints": {"description":
    "Explicit constraints or ''unspecified''", "title": "Constraints", "type": "string"}},
    "required": ["name", "description", "type", "constraints"], "title": "Parameter",
    "type": "object"}}, "properties": {"parameters": {"items": {"$ref": "#/$defs/Parameter"},
    "title": "Parameters", "type": "array"}}, "required": ["parameters"]}

    ```



    Excerpt from RISC-V(extract parameters from the following text):

    Privileged Spec 2.1:

    "Conventional" R/W accessibility of CSRs according to address mapping

    The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
    to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
    are used to encode the read and write accessibility of the CSRs according to privilege
    level as shown in Table 1. The top two bits (csr[11:10]) indicate whether the
    register is read/write (00,01, or 10) or read-only (11). The next two bits (csr[9:8])
    encode the lowest privilege level that can access the CSR.


    '
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr[11:10]
        description: Top two bits of the CSR address indicating whether the register
          is read/write or read-only.
        type: enum
        constraints: Enum values are 00, 01, 10, and 11
      - name: csr[9:8]
        description: Next two bits of the CSR address encoding the lowest privilege
          level that can access the CSR.
        type: integer
        constraints: Unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr[11:8]
        description: upper 4 bits of the CSR address used for encoding read and write
          accessibility of CSRs
        type: enum
        constraints: Table 1 in Privileged Spec 2.1
      - name: csr[11:10]
        description: top two bits of the CSR address indicating read/write or read-only
          access
        type: enum
        constraints: Table 1 in Privileged Spec 2.1
      - name: csr[9:8]
        description: next two bits of the CSR address encoding the lowest privilege
          level that can access the CSR
        type: enum
        constraints: Table 1 in Privileged Spec 2.1
- prompting_technique: zero_shot4
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make, which influence architectural behavior and must be tolerated by software.\n\
    These parameters arise where the ISA allows implementation freedom rather than\
    \ mandating one behavior.\nTypical cases include:\n\u2022 Implementation-defined\
    \ sizes or limits\n\u2022 Optional features\n\u2022 Implementation-dependent behavior\n\
    \u2022 WARL CSR field legal value ranges and mappings\nParameters are generally\
    \ not directly controlled by software-visible architectural state, but are properties\
    \ of the implementation.\n\nYou are an expert hardware designer with years of\
    \ experience in RISC-V.\n\nTask:\nYou will be given excerpts from RISC-V Instruction\
    \ Set Manual (RISC-V ISA) and have to extract architectural parameters from them.\n\
    The usage of following words usually implies a parameter so put extra focus on\
    \ them:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific\nbut it maybe that the above words are not present but a parameter\
    \ is defined.\n\nRules:\n- Do NOT infer unstated behavior\n- Do NOT describe the\
    \ schema\n- Output ONLY data\n- If no constraint is given, write unspecified\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 19.3.1:\nCaches organize copies of data into cache blocks, each\
    \ of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity and organization of a cache are implementation-specific.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific but shall
          be uniform throughout the system.
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache block size
        description: size of a cache block
        type: integer
        constraints: unspecified
      - name: cache capacity
        description: capacity of a cache
        type: integer
        constraints: unspecified
      - name: cache organization
        description: organization of a cache
        type: string
        constraints: unspecified
- prompting_technique: zero_shot4
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make, which influence architectural behavior and must be tolerated by software.\n\
    These parameters arise where the ISA allows implementation freedom rather than\
    \ mandating one behavior.\nTypical cases include:\n\u2022 Implementation-defined\
    \ sizes or limits\n\u2022 Optional features\n\u2022 Implementation-dependent behavior\n\
    \u2022 WARL CSR field legal value ranges and mappings\nParameters are generally\
    \ not directly controlled by software-visible architectural state, but are properties\
    \ of the implementation.\n\nYou are an expert hardware designer with years of\
    \ experience in RISC-V.\n\nTask:\nYou will be given excerpts from RISC-V Instruction\
    \ Set Manual (RISC-V ISA) and have to extract architectural parameters from them.\n\
    The usage of following words usually implies a parameter so put extra focus on\
    \ them:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific\nbut it maybe that the above words are not present but a parameter\
    \ is defined.\n\nRules:\n- Do NOT infer unstated behavior\n- Do NOT describe the\
    \ schema\n- Output ONLY data\n- If no constraint is given, write unspecified\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to\
    \ address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: CSR Accessibility
        description: The read and write accessibility of CSRs according to privilege
          level.
        type: enum
        constraints: 00=read/write, 01=read/write, 10=read/write, 11=read-only
      - name: Lowest Privilege Level Access
        description: The lowest privilege level that can access the CSR.
        type: enum
        constraints: encoded in csr[9:8]
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr encoding space size
        description: Size of the CSR encoding space
        type: integer
        constraints: 12-bit encoding space (csr[11:0])
      - name: number of csrs
        description: Number of CSRs
        type: integer
        constraints: up to 4,096 CSRs
      - name: csr address bits
        description: Upper 4 bits of the CSR address
        type: integer
        constraints: csr[11:8]
      - name: accessibility encoding
        description: Encoding of read and write accessibility
        type: enum
        constraints: 00,01, or 10 for read/write, 11 for read-only
      - name: privilege level encoding
        description: Encoding of lowest privilege level
        type: enum
        constraints: csr[9:8]
- prompting_technique: prompt_with_1ex
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make which influence architectural behavior and must be tolerated by software.\n\
    These parameters arise where the ISA allows implementation freedom rather than\
    \ mandating one behavior.\nTypical cases include:\n\u2022 Implementation-defined\
    \ sizes or limits\n\u2022 Optional features or behaviors\n\u2022 Implementation-dependent\
    \ behavior\n\u2022 WARL CSR field legal value ranges and illegal-to-legal mappings\n\
    \nParameters are not directly controlled by software-visible architectural state,\
    \ but are properties of the implementation.\nYou are an expert hardware designer\
    \ with years of experience in RISC-V.\n\nTask:\nYou will be given excerpts from\
    \ the RISC-V Instruction Set Manual and must extract architectural parameters\
    \ from them.\n\nThe usage of following words usually implies a parameter so put\
    \ extra focus on them:\nmay,might,should,\noptional,optionally,\nimplementation\
    \ defined,implementation specific,either, can.\n\nHowever, parameters may exist\
    \ even when these words are absent.\n\nRules:\n- Extract only implementation-defined\
    \ choices affecting architectural behavior.\n- Do NOT infer unstated behavior.\n\
    - Do NOT extract mechanisms provided to software (such as discovery interfaces).\n\
    - Do NOT describe the schema.\n- Output ONLY data.\n- If no constraint is given,\
    \ write unspecified.\n- Extract a parameter only if different implementations\
    \ may behave differently because of it.\n\nExamples:\n- name: means to discover\
    \ cache information\n  description: A means provided by the execution environment\
    \ to discover information about caches and cache blocks\n  type: string\n  constraints:\
    \ unspecified\nThis is a negative example. It is a software mechanism, not an\
    \ implementation parameter.\n\nname: cache_capacity\ndescription: The capacity\
    \ of a cache is implementation-specific.\ntype: integer\nconstraints: unspecified\n\
    This is a positive example since the capacity is implementation-specific and decided\
    \ by the hardware designer.\n\nInstructions on how to format the output:\nThe\
    \ output should be formatted as a JSON instance that conforms to the JSON schema\
    \ below.\n\nAs an example, for the schema {\"properties\": {\"foo\": {\"title\"\
    : \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\"\
    : {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"\
    bar\", \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\"\
    : {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\nHere is the output\
    \ schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\": {\"name\": {\"description\"\
    : \"Concise parameter name given in the specification or derived from the description\"\
    , \"title\": \"Name\", \"type\": \"string\"}, \"description\": {\"description\"\
    : \"Description derived strictly from the specification explaining what behavior\
    \ or capability varies due to this implementation-defined parameter\", \"title\"\
    : \"Description\", \"type\": \"string\"}, \"type\": {\"description\": \"type of\
    \ values the parameter takes : integer | boolean | enum | bitfield | range | structural\"\
    , \"title\": \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\"\
    : \"Explicit constraints on the values that the parameter can take or 'unspecified'\"\
    , \"title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\"\
    , \"description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nIf the specification refers to external tables or sections for constraints,\
    \ write constraints as unspecified.\n\nExcerpt from RISC-V (extract parameters\
    \ from the following text):\nPrivileged Spec 19.3.1:\nCaches organize copies of\
    \ data into cache blocks, each of which represents a contiguous, naturally aligned\
    \ power-of-two (or NAPOT) range of memory locations. A cache block is identified\
    \ by any of the physical addresses corresponding to the underlying memory locations.\
    \ The capacity and organization of a cache and the size of a cache block are both\
    \ implementation-specific, and the execution environment provides software a means\
    \ to discover information about the caches and cache blocks in a system. In the\
    \ initial set of CMO extensions, the size of a cache block shall be uniform throughout\
    \ the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parse_error: true
      error: "Failed to parse ParameterList from completion [{\"name\": \"cache_capacity\"\
        , \"description\": \"The capacity of a cache is implementation-specific.\"\
        , \"type\": \"integer\", \"constraints\": \"unspecified\"}, {\"name\": \"\
        cache_block_size\", \"description\": \"The size of a cache block is implementation-specific,\
        \ though it is uniform throughout the system according to the initial set\
        \ of CMO extensions.\", \"type\": \"integer\", \"constraints\": \"unspecified\"\
        }]. Got: 1 validation error for ParameterList\n  Input should be a valid dictionary\
        \ or instance of ParameterList [type=model_type, input_value=[{'name': 'cache_capacity...raints':\
        \ 'unspecified'}], input_type=list]\n    For further information visit https://errors.pydantic.dev/2.12/v/model_type\n\
        For troubleshooting, visit: https://docs.langchain.com/oss/python/langchain/errors/OUTPUT_PARSING_FAILURE "
      raw_output: "```json\n[\n    {\n        \"name\": \"cache_capacity\",\n    \
        \    \"description\": \"The capacity of a cache is implementation-specific.\"\
        ,\n        \"type\": \"integer\",\n        \"constraints\": \"unspecified\"\
        \n    },\n    {\n        \"name\": \"cache_block_size\",\n        \"description\"\
        : \"The size of a cache block is implementation-specific, though it is uniform\
        \ throughout the system according to the initial set of CMO extensions.\"\
        ,\n        \"type\": \"integer\",\n        \"constraints\": \"unspecified\"\
        \n    }\n]\n```"
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parse_error: true
      error: "Failed to parse ParameterList from completion {\"parameters\": [{\"\
        name\": \"cache_capacity\", \"description\": \"The capacity of a cache is\
        \ implementation-specific.\", \"type\": \"unspecified\", \"constraints\":\
        \ \"unspecified\"}, {\"name\": \"cache_block_size\", \"description\": \"The\
        \ size of a cache block is implementation-specific.\", \"type\": \"unspecified\"\
        , \"constraints\": \"unspecified\"}, {\"name\": \"cache_organization\", \"\
        description\": \"The organization of a cache is implementation-specific.\"\
        }]}. Got: 2 validation errors for ParameterList\nparameters.2.type\n  Field\
        \ required [type=missing, input_value={'name': 'cache_organizat...plementation-specific.'},\
        \ input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\n\
        parameters.2.constraints\n  Field required [type=missing, input_value={'name':\
        \ 'cache_organizat...plementation-specific.'}, input_type=dict]\n    For further\
        \ information visit https://errors.pydantic.dev/2.12/v/missing\nFor troubleshooting,\
        \ visit: https://docs.langchain.com/oss/python/langchain/errors/OUTPUT_PARSING_FAILURE "
      raw_output: "{\n  \"parameters\": [\n    {\n      \"name\": \"cache_capacity\"\
        ,\n      \"description\": \"The capacity of a cache is implementation-specific.\"\
        ,\n      \"type\": \"unspecified\",\n      \"constraints\": \"unspecified\"\
        \n    },\n    {\n      \"name\": \"cache_block_size\",\n      \"description\"\
        : \"The size of a cache block is implementation-specific.\",\n      \"type\"\
        : \"unspecified\",\n      \"constraints\": \"unspecified\"\n    },\n    {\n\
        \      \"name\": \"cache_organization\",\n      \"description\": \"The organization\
        \ of a cache is implementation-specific.\"\n    }\n  ]\n}"
- prompting_technique: prompt_with_1ex
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make which influence architectural behavior and must be tolerated by software.\n\
    These parameters arise where the ISA allows implementation freedom rather than\
    \ mandating one behavior.\nTypical cases include:\n\u2022 Implementation-defined\
    \ sizes or limits\n\u2022 Optional features or behaviors\n\u2022 Implementation-dependent\
    \ behavior\n\u2022 WARL CSR field legal value ranges and illegal-to-legal mappings\n\
    \nParameters are not directly controlled by software-visible architectural state,\
    \ but are properties of the implementation.\nYou are an expert hardware designer\
    \ with years of experience in RISC-V.\n\nTask:\nYou will be given excerpts from\
    \ the RISC-V Instruction Set Manual and must extract architectural parameters\
    \ from them.\n\nThe usage of following words usually implies a parameter so put\
    \ extra focus on them:\nmay,might,should,\noptional,optionally,\nimplementation\
    \ defined,implementation specific,either, can.\n\nHowever, parameters may exist\
    \ even when these words are absent.\n\nRules:\n- Extract only implementation-defined\
    \ choices affecting architectural behavior.\n- Do NOT infer unstated behavior.\n\
    - Do NOT extract mechanisms provided to software (such as discovery interfaces).\n\
    - Do NOT describe the schema.\n- Output ONLY data.\n- If no constraint is given,\
    \ write unspecified.\n- Extract a parameter only if different implementations\
    \ may behave differently because of it.\n\nExamples:\n- name: means to discover\
    \ cache information\n  description: A means provided by the execution environment\
    \ to discover information about caches and cache blocks\n  type: string\n  constraints:\
    \ unspecified\nThis is a negative example. It is a software mechanism, not an\
    \ implementation parameter.\n\nname: cache_capacity\ndescription: The capacity\
    \ of a cache is implementation-specific.\ntype: integer\nconstraints: unspecified\n\
    This is a positive example since the capacity is implementation-specific and decided\
    \ by the hardware designer.\n\nInstructions on how to format the output:\nThe\
    \ output should be formatted as a JSON instance that conforms to the JSON schema\
    \ below.\n\nAs an example, for the schema {\"properties\": {\"foo\": {\"title\"\
    : \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\"\
    : {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"\
    bar\", \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\"\
    : {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\nHere is the output\
    \ schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\": {\"name\": {\"description\"\
    : \"Concise parameter name given in the specification or derived from the description\"\
    , \"title\": \"Name\", \"type\": \"string\"}, \"description\": {\"description\"\
    : \"Description derived strictly from the specification explaining what behavior\
    \ or capability varies due to this implementation-defined parameter\", \"title\"\
    : \"Description\", \"type\": \"string\"}, \"type\": {\"description\": \"type of\
    \ values the parameter takes : integer | boolean | enum | bitfield | range | structural\"\
    , \"title\": \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\"\
    : \"Explicit constraints on the values that the parameter can take or 'unspecified'\"\
    , \"title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\"\
    , \"description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nIf the specification refers to external tables or sections for constraints,\
    \ write constraints as unspecified.\n\nExcerpt from RISC-V (extract parameters\
    \ from the following text):\nPrivileged Spec 2.1:\n\"Conventional\" R/W accessibility\
    \ of CSRs according to address mapping\nThe standard RISC-V ISA sets aside a 12-bit\
    \ encoding space (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4\
    \ bits of the CSR address (csr[11:8]) are used to encode the read and write accessibility\
    \ of the CSRs according to privilege level as shown in Table 1. The top two bits\
    \ (csr[11:10]) indicate whether the register is read/write (00,01, or 10) or read-only\
    \ (11). The next two bits (csr[9:8]) encode the lowest privilege level that can\
    \ access the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_accessibility
        description: The read and write accessibility of CSRs according to privilege
          level is implementation-specific.
        type: enum
        constraints: unspecified
      - name: lowest_privilege_level
        description: The lowest privilege level that can access a CSR is implementation-specific.
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parse_error: true
      error: "Failed to parse ParameterList from completion {\"parameters\": [\"csr[11:10]\"\
        , \"csr[9:8]\"]}. Got: 2 validation errors for ParameterList\nparameters.0\n\
        \  Input should be a valid dictionary or instance of Parameter [type=model_type,\
        \ input_value='csr[11:10]', input_type=str]\n    For further information visit\
        \ https://errors.pydantic.dev/2.12/v/model_type\nparameters.1\n  Input should\
        \ be a valid dictionary or instance of Parameter [type=model_type, input_value='csr[9:8]',\
        \ input_type=str]\n    For further information visit https://errors.pydantic.dev/2.12/v/model_type\n\
        For troubleshooting, visit: https://docs.langchain.com/oss/python/langchain/errors/OUTPUT_PARSING_FAILURE "
      raw_output: "{\"parameters\": [\"csr[11:10]\", \"csr[9:8]\"]} \n\nExplanation:\n\
        \n- The specification refers to Table 1 for the exact mapping, so we cannot\
        \ determine the exact behavior.\n- However, the description indicates that\
        \ the top two bits (csr[11:10]) and the next two bits (csr[9:8]) are used\
        \ to encode the read and write accessibility of the CSRs.\n- This means that\
        \ the values of these bits may vary between implementations, depending on\
        \ how the accessibility of CSRs is implemented.\n\nCSR field legal value ranges\
        \ and illegal-to-legal mappings are implementation-dependent, and the two\
        \ parameters are a part of it.\n\nSo the output is an array of two parameters."
- prompting_technique: prompt6
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make which influence architectural behavior and must be tolerated by software.\n\
    Typical cases include:\n\u2022 Implementation-defined sizes or limits\n\u2022\
    \ Optional features or behaviors\n\u2022 Implementation-dependent behavior\n\u2022\
    \ WARL CSR field legal value ranges and illegal-to-legal mappings\n\nParameters\
    \ are not directly controlled by software-visible architectural state, but are\
    \ properties of the implementation.\nYou are an expert hardware designer with\
    \ years of experience in RISC-V.\n\nTask:\nYou will be given excerpts from the\
    \ RISC-V Instruction Set Manual and must extract architectural parameters from\
    \ them.\n\nThe usage of following words usually implies a parameter so pay special\
    \ attention on them:\nmay,might,should,\noptional,optionally,\nimplementation\
    \ defined,implementation specific,either, can.\n\nHowever, parameters may exist\
    \ even when these words are absent.\n\nRules:\n- Do NOT infer unstated behavior.\n\
    - Do NOT describe the schema.\n- If constraint refers to external source write\
    \ unspecified.\n\nExamples:\n- name: means to discover cache information\n  description:\
    \ A means provided by the execution environment to discover information about\
    \ caches and cache blocks\n  type: string\n  constraints: unspecified\nThis is\
    \ a negative example. It is a software mechanism, not an implementation parameter.\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V:\nPrivileged Spec 19.3.1:\nCaches organize copies\
    \ of data into cache blocks, each of which represents a contiguous, naturally\
    \ aligned power-of-two (or NAPOT) range of memory locations. A cache block is\
    \ identified by any of the physical addresses corresponding to the underlying\
    \ memory locations. The capacity and organization of a cache and the size of a\
    \ cache block are both implementation-specific, and the execution environment\
    \ provides software a means to discover information about the caches and cache\
    \ blocks in a system. In the initial set of CMO extensions, the size of a cache\
    \ block shall be uniform throughout the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity_and_organization
        description: The capacity and organization of a cache are implementation-specific.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific, but it
          shall be uniform throughout the system in the initial set of CMO extensions.
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: Size of a cache block, which is implementation-specific and can
          vary between systems.
        type: range
        constraints: unspecified
      - name: cache_capacity
        description: Capacity of a cache, which is implementation-specific and can
          vary between systems.
        type: range
        constraints: unspecified
      - name: cache_organization
        description: Organization of a cache, which is implementation-specific and
          can vary between systems.
        type: enum
        constraints: unspecified
- prompting_technique: prompt6
  prompt: "\nRISC-V is an open standard Instruction Set Architecture (ISA) defining\
    \ the instructions and architectural behavior of processors.\nIn this context,\
    \ architectural parameters are implementation-defined choices that hardware designers\
    \ make which influence architectural behavior and must be tolerated by software.\n\
    Typical cases include:\n\u2022 Implementation-defined sizes or limits\n\u2022\
    \ Optional features or behaviors\n\u2022 Implementation-dependent behavior\n\u2022\
    \ WARL CSR field legal value ranges and illegal-to-legal mappings\n\nParameters\
    \ are not directly controlled by software-visible architectural state, but are\
    \ properties of the implementation.\nYou are an expert hardware designer with\
    \ years of experience in RISC-V.\n\nTask:\nYou will be given excerpts from the\
    \ RISC-V Instruction Set Manual and must extract architectural parameters from\
    \ them.\n\nThe usage of following words usually implies a parameter so pay special\
    \ attention on them:\nmay,might,should,\noptional,optionally,\nimplementation\
    \ defined,implementation specific,either, can.\n\nHowever, parameters may exist\
    \ even when these words are absent.\n\nRules:\n- Do NOT infer unstated behavior.\n\
    - Do NOT describe the schema.\n- If constraint refers to external source write\
    \ unspecified.\n\nExamples:\n- name: means to discover cache information\n  description:\
    \ A means provided by the execution environment to discover information about\
    \ caches and cache blocks\n  type: string\n  constraints: unspecified\nThis is\
    \ a negative example. It is a software mechanism, not an implementation parameter.\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V:\nPrivileged Spec 2.1:\n\"Conventional\" R/W\
    \ accessibility of CSRs according to address mapping\nThe standard RISC-V ISA\
    \ sets aside a 12-bit encoding space (csr[11:0]) for up to 4,096 CSRs. By convention,\
    \ the upper 4 bits of the CSR address (csr[11:8]) are used to encode the read\
    \ and write accessibility of the CSRs according to privilege level as shown in\
    \ Table 1. The top two bits (csr[11:10]) indicate whether the register is read/write\
    \ (00,01, or 10) or read-only (11). The next two bits (csr[9:8]) encode the lowest\
    \ privilege level that can access the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_accessibility
        description: The upper 4 bits (csr[11:8]) of the CSR address encode the read
          and write accessibility of the CSRs according to the privilege level.
        type: bitfield
        constraints: unspecified
      - name: read_write_indication
        description: The top two bits (csr[11:10]) indicate whether the register is
          read/write (00, 01, or 10) or read-only (11).
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_address_width
        description: Width of the CSR address in bits.
        type: integer
        constraints: unspecified
      - name: csr_encoding_space
        description: Size of the CSR encoding space in bits.
        type: integer
        constraints: unspecified
      - name: csr_privilege_bits
        description: Number of bits used to encode the privilege level of a CSR.
        type: integer
        constraints: unspecified
      - name: csr_accessibility_encoding
        description: Method of encoding the read and write accessibility of CSRs.
        type: enum
        constraints: unspecified
- prompting_technique: prompt7
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\n\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific\nHowever,\
    \ parameters may exist even when these words are absent.\n\nRules:\n- Do NOT infer\
    \ unstated behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ write unspecified.\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\nInstructions on how to format the output:\nThe output should be\
    \ formatted as a JSON instance that conforms to the JSON schema below.\n\nAs an\
    \ example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\"\
    : \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 19.3.1:\nCaches organize copies of data into cache blocks, each\
    \ of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache is implementation-specific.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache is implementation-specific.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific and shall
          be uniform throughout the system.
        type: integer
        constraints: uniform
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache block size
        description: The size of a cache block
        type: unspecified
        constraints: implementation-specific
      - name: cache capacity
        description: The capacity of a cache
        type: unspecified
        constraints: implementation-specific
      - name: cache organization
        description: The organization of a cache
        type: unspecified
        constraints: implementation-specific
      - name: cache discovery
        description: A means provided by the execution environment to discover information
          about caches and cache blocks
        type: unspecified
        constraints: unspecified
- prompting_technique: prompt7
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\n\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific\nHowever,\
    \ parameters may exist even when these words are absent.\n\nRules:\n- Do NOT infer\
    \ unstated behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ write unspecified.\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\nInstructions on how to format the output:\nThe output should be\
    \ formatted as a JSON instance that conforms to the JSON schema below.\n\nAs an\
    \ example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\"\
    : \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to\
    \ address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_accessibility
        description: The read and write accessibility of the CSRs according to privilege
          level, encoded in csr[11:8]
        type: bitfield
        constraints: unspecified
      - name: read_write_indicator
        description: Indicates whether the CSR is read/write (00,01, or 10) or read-only
          (11), encoded in csr[11:10]
        type: bitfield
        constraints: unspecified
      - name: lowest_privilege_level
        description: Encodes the lowest privilege level that can access the CSR, encoded
          in csr[9:8]
        type: bitfield
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_encoding_bits
        description: bits used to encode the read and write accessibility of CSRs
        type: range
        constraints: csr[11:10] for read/write accessibility, csr[9:8] for lowest
          privilege level
      - name: csr_address_mapping
        description: mapping of CSRs to 12-bit encoding space
        type: unspecified
        constraints: unspecified
- prompting_technique: prompt8
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard that we have to follow it giving us no choice\
    \ it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\nYou will be given\
    \ excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and have to extract\
    \ architectural parameters from them.\nThe usage of following words usually implies\
    \ a parameter so put extra focus on them:\nmay/might/should,\noptional/optionally,\n\
    implementation defined/implementation specific,\ncan/either\nHowever, parameters\
    \ may exist even when these words are absent.\n\nRules:\n- Do NOT infer unstated\
    \ behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no constraint\
    \ is given, write unspecified\n- If constraint refers to external source write\
    \ unspecified.\n\nExamples:\n- name: means to discover cache information\n  description:\
    \ A means provided by the execution environment to discover information about\
    \ caches and cache blocks\n  type: string\n  constraints: unspecified\nThis is\
    \ a negative example. It is a software mechanism, not an implementation parameter.\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 19.3.1:\nCaches organize copies of data into cache blocks, each\
    \ of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache is implementation-specific.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache is implementation-specific.
        type: string
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific but shall
          be uniform throughout the system in the initial set of CMO extensions.
        type: integer
        constraints: uniform
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: The size of a cache block is implementation-specific
        type: unspecified
        constraints: implementation-specific
      - name: cache_capacity
        description: The capacity of a cache is implementation-specific
        type: unspecified
        constraints: implementation-specific
      - name: cache_organisation
        description: The organization of a cache is implementation-specific
        type: unspecified
        constraints: implementation-specific
- prompting_technique: prompt8
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard that we have to follow it giving us no choice\
    \ it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\nYou will be given\
    \ excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and have to extract\
    \ architectural parameters from them.\nThe usage of following words usually implies\
    \ a parameter so put extra focus on them:\nmay/might/should,\noptional/optionally,\n\
    implementation defined/implementation specific,\ncan/either\nHowever, parameters\
    \ may exist even when these words are absent.\n\nRules:\n- Do NOT infer unstated\
    \ behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no constraint\
    \ is given, write unspecified\n- If constraint refers to external source write\
    \ unspecified.\n\nExamples:\n- name: means to discover cache information\n  description:\
    \ A means provided by the execution environment to discover information about\
    \ caches and cache blocks\n  type: string\n  constraints: unspecified\nThis is\
    \ a negative example. It is a software mechanism, not an implementation parameter.\n\
    \nInstructions on how to format the output:\nThe output should be formatted as\
    \ a JSON instance that conforms to the JSON schema below.\n\nAs an example, for\
    \ the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\":\
    \ \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"\
    }}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted\
    \ instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"\
    ]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"\
    Parameter\": {\"properties\": {\"name\": {\"description\": \"Concise parameter\
    \ name given in the specification or derived from the description\", \"title\"\
    : \"Name\", \"type\": \"string\"}, \"description\": {\"description\": \"Description\
    \ derived strictly from the specification explaining what behavior or capability\
    \ varies due to this implementation-defined parameter\", \"title\": \"Description\"\
    , \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to\
    \ address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr[11:10]
        description: Indicates whether the CSR is read/write (00, 01, or 10) or read-only
          (11)
        type: enum
        constraints: unspecified
      - name: csr[9:8]
        description: Encodes the lowest privilege level that can access the CSR
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr[11:10] encoding
        description: Indicates whether the register is read/write or read-only
        type: enum
        constraints: '00: read/write, 01: read/write, 10: read/write, 11: read-only'
      - name: csr[9:8] encoding
        description: Encodes the lowest privilege level that can access the CSR
        type: enum
        constraints: unspecified
- prompting_technique: prompt9
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every exercpt will contain parameters.\n\nRules:\n- Do NOT infer\
    \ unstated behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ write unspecified.\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\n name: cache_capacity\n description: The capacity of a cache,\
    \ which may affect the number of cache\n blocks it can store.\n type: range\n\
    \ constraints: unspecified\n name: cache_organization\n description: The organization\
    \ of a cache, including the arrangement of cache\n blocks and their corresponding\
    \ tags.\n type: enum\n constraints: unspecified\n These are positive examples\
    \ as changes in them affect the processor behavior and they dont have any previously\
    \ defined standard value.\n\nInstructions on how to format the output:\nThe output\
    \ should be formatted as a JSON instance that conforms to the JSON schema below.\n\
    \nAs an example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\"\
    , \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"\
    type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\"\
    , \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\"\
    : {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\nHere is the output\
    \ schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\": {\"name\": {\"description\"\
    : \"Concise parameter name given in the specification or derived from the description\"\
    , \"title\": \"Name\", \"type\": \"string\"}, \"description\": {\"description\"\
    : \"Description derived strictly from the specification explaining what behavior\
    \ or capability varies due to this implementation-defined parameter\", \"title\"\
    : \"Description\", \"type\": \"string\"}, \"type\": {\"description\": \"type of\
    \ values the parameter takes : integer | boolean | enum | bitfield | range | structural\"\
    , \"title\": \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\"\
    : \"Explicit constraints on the values that the parameter can take or 'unspecified'\"\
    , \"title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\"\
    , \"description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 19.3.1:\nCaches organize copies of data into cache blocks, each\
    \ of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache, which may affect the number of cache
          blocks it can store.
        type: range
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache, including the arrangement of cache
          blocks and their corresponding tags.
        type: enum
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block, which is uniform throughout the system
          according to the initial set of CMO extensions.
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache, which may affect the number of cache
          blocks it can store.
        type: range
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache, including the arrangement of cache
          blocks and their corresponding tags.
        type: enum
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block, which is uniform throughout the system.
        type: range
        constraints: unspecified
- prompting_technique: prompt9
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every exercpt will contain parameters.\n\nRules:\n- Do NOT infer\
    \ unstated behavior\n- Do NOT describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ write unspecified.\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\n name: cache_capacity\n description: The capacity of a cache,\
    \ which may affect the number of cache\n blocks it can store.\n type: range\n\
    \ constraints: unspecified\n name: cache_organization\n description: The organization\
    \ of a cache, including the arrangement of cache\n blocks and their corresponding\
    \ tags.\n type: enum\n constraints: unspecified\n These are positive examples\
    \ as changes in them affect the processor behavior and they dont have any previously\
    \ defined standard value.\n\nInstructions on how to format the output:\nThe output\
    \ should be formatted as a JSON instance that conforms to the JSON schema below.\n\
    \nAs an example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\"\
    , \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"\
    type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\"\
    , \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\"\
    : {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\nHere is the output\
    \ schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\": {\"name\": {\"description\"\
    : \"Concise parameter name given in the specification or derived from the description\"\
    , \"title\": \"Name\", \"type\": \"string\"}, \"description\": {\"description\"\
    : \"Description derived strictly from the specification explaining what behavior\
    \ or capability varies due to this implementation-defined parameter\", \"title\"\
    : \"Description\", \"type\": \"string\"}, \"type\": {\"description\": \"type of\
    \ values the parameter takes : integer | boolean | enum | bitfield | range | structural\"\
    , \"title\": \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\"\
    : \"Explicit constraints on the values that the parameter can take or 'unspecified'\"\
    , \"title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\"\
    , \"description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\n\nExcerpt from RISC-V(extract parameters from the following text):\n\
    Privileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to\
    \ address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_accessibility
        description: The read and write accessibility of CSRs according to privilege
          level.
        type: enum
        constraints: unspecified
      - name: lowest_privilege_level
        description: The lowest privilege level that can access the CSR.
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_accessibility_encoding
        description: Encoding of read and write accessibility of CSRs according to
          privilege level
        type: enum
        constraints: unspecified
      - name: csr_address_mapping
        description: Mapping of CSRs to addresses
        type: unspecified
        constraints: unspecified
      - name: csr_encoding_space
        description: 12-bit encoding space for up to 4,096 CSRs
        type: unspecified
        constraints: unspecified
      - name: csr_privilege_level_encoding
        description: Encoding of lowest privilege level that can access the CSR
        type: enum
        constraints: unspecified
- prompting_technique: prompt10
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every exercpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER infer\
    \ unstated behavior\n- NEVER describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ NEVER WRITE IT INSTEAD WRITE unspecified.\n\nReasoning Process (Think Step-by-Step):\n\
    For every potential parameter, ask:\n1. Is this a fixed rule I must follow to\
    \ be RISC-V Compliant? (If yes, discard).\n2. Is this a field labeled WARL (Write\
    \ Any values, Reads Legal values)? (If yes, it is a parameter for legal values\
    \ and mapping).\n3. Does the text allow for different 'BEHAVIOUR' or 'VALUES'\
    \ across different chips? (If yes, extract the choice).\n4. Once choice is extracted\
    \ check if the spec specifies a type or constraint on its values.(REFER TO RULES\
    \ AND FORMAT INSTRUCTIONS).\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\n name: cache_capacity\n description: The capacity of a cache,\
    \ which may affect the number of cache\n blocks it can store.\n type: range\n\
    \ constraints: unspecified\n This is a positive examples as changes in them affect\
    \ the processor behavior and they dont have any previously defined standard value.\n\
    \n\nExcerpt from RISC-V(extract parameters from the following text):\nPrivileged\
    \ Spec 19.3.1:\nCaches organize copies of data into cache blocks, each of which\
    \ represents a contiguous, naturally aligned power-of-two (or NAPOT) range of\
    \ memory locations. A cache block is identified by any of the physical addresses\
    \ corresponding to the underlying memory locations. The capacity and organization\
    \ of a cache and the size of a cache block are both implementation-specific, and\
    \ the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache, which may affect the number of cache
          blocks it can store.
        type: range
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block, which is implementation-specific and
          shall be uniform throughout the system according to the initial set of CMO
          extensions.
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache, which may affect the number of cache
          blocks it can store.
        type: range
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block, which is uniform throughout the system.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache, which may affect the mapping between
          physical addresses and cache blocks.
        type: enum
        constraints: unspecified
- prompting_technique: prompt10
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every exercpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER infer\
    \ unstated behavior\n- NEVER describe the schema\n- Output ONLY data\n- If no\
    \ constraint is given, write unspecified\n- If constraint refers to external source\
    \ NEVER WRITE IT INSTEAD WRITE unspecified.\n\nReasoning Process (Think Step-by-Step):\n\
    For every potential parameter, ask:\n1. Is this a fixed rule I must follow to\
    \ be RISC-V Compliant? (If yes, discard).\n2. Is this a field labeled WARL (Write\
    \ Any values, Reads Legal values)? (If yes, it is a parameter for legal values\
    \ and mapping).\n3. Does the text allow for different 'BEHAVIOUR' or 'VALUES'\
    \ across different chips? (If yes, extract the choice).\n4. Once choice is extracted\
    \ check if the spec specifies a type or constraint on its values.(REFER TO RULES\
    \ AND FORMAT INSTRUCTIONS).\n\nExamples:\n- name: means to discover cache information\n\
    \  description: A means provided by the execution environment to discover information\
    \ about caches and cache blocks\n  type: string\n  constraints: unspecified\n\
    This is a negative example. It is a software mechanism, not an implementation\
    \ parameter.\n\n name: cache_capacity\n description: The capacity of a cache,\
    \ which may affect the number of cache\n blocks it can store.\n type: range\n\
    \ constraints: unspecified\n This is a positive examples as changes in them affect\
    \ the processor behavior and they dont have any previously defined standard value.\n\
    \n\nExcerpt from RISC-V(extract parameters from the following text):\nPrivileged\
    \ Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to address mapping\n\
    The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up\
    \ to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])\
    \ are used to encode the read and write accessibility of the CSRs according to\
    \ privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate\
    \ whether the register is read/write (00,01, or 10) or read-only (11). The next\
    \ two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.\n\
    \n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_accessibility
        description: The read and write accessibility of CSRs according to privilege
          level, encoded in csr[11:8]
        type: enum
        constraints: unspecified
      - name: csr_read_only
        description: Indicates whether the CSR is read-only, encoded in csr[11:10]
          as 11
        type: boolean
        constraints: unspecified
      - name: lowest_privilege_level_access
        description: The lowest privilege level that can access the CSR, encoded in
          csr[9:8]
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_accessibility_encoding
        description: The encoding used to represent read and write accessibility of
          CSRs according to privilege level.
        type: enum
        constraints: unspecified
      - name: csr_privilege_level_encoding
        description: The encoding used to represent the lowest privilege level that
          can access a CSR.
        type: enum
        constraints: unspecified
- prompting_technique: prompt11
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every excerpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER describe\
    \ the schema.\n- If constraint refers to external source NEVER WRITE IT; INSTEAD\
    \ WRITE unspecified.\n- Output ONLY data.\n\nReasoning Process (Think Step-by-Step):\n\
    1. Is this a fixed rule or address mapping set by the ISA? Even if it is called\
    \ a 'convention', if it must be followed for standard compliance, DISCARD it.\n\
    2. Is this a field labeled WARL (Write Any values, Reads Legal values)? If yes,\
    \ it is ALWAYS a parameter for legal values and mapping behavior.\n3. Does the\
    \ text allow for different 'BEHAVIOUR' or 'VALUES' across different chips? If\
    \ the hardware designer has a choice between A or B, EXTRACT it.\n4. Once a choice\
    \ is extracted, check if the spec specifies a type or constraint on its values.\n\
    \nExamples:\n- Text: 'By convention, the red light is always located at the top\
    \ of the traffic signal and indicates that the vehicle must stop.'\n  Reasoning:\
    \ This is a fixed standard ('By convention') required for the system to work.\
    \ A manufacturer cannot choose to put the red light at the bottom and remain compliant.\n\
    \  Result: 'parameters: []'\n  (This is a negative example: showing what NOT to\
    \ extract).\n\n- Text: 'The horsepower and fuel-tank capacity of an engine and\
    \ the material of the seats are all manufacturer-specific.'\n  Reasoning: The\
    \ phrase 'manufacturer-specific' indicates these are choices the builder makes.\
    \ Different versions of the car will have different values.\n  Output:\n  - name:\
    \ engine_horsepower\n    description: The power output of the engine as determined\
    \ by the manufacturer.\n    type: range\n    constraints: manufacturer-specific\n\
    \  - name: fuel_tank_capacity\n    description: The total volume of fuel the vehicle\
    \ can store.\n    type: range\n    constraints: manufacturer-specific\n  - name:\
    \ seat_material\n    description: The type of material used for the interior upholstery.\n\
    \    type: enum\n    constraints: manufacturer-specific\n  This is a positive\
    \ example.\n\nExcerpt from RISC-V (extract parameters from the following text):\n\
    Privileged Spec 19.3.1:\nCaches organize copies of data into cache blocks, each\
    \ of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of the cache.
        type: range
        constraints: unspecified
      - name: cache_organization
        description: The organization of the cache.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block.
        type: range
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The amount of data stored in a cache.
        type: range
        constraints: implementation-specific
      - name: cache_block_size
        description: The size of a cache block, which is a contiguous range of memory
          locations.
        type: range
        constraints: implementation-specific
      - name: cache_organization
        description: The way cache blocks are organized in memory.
        type: enum
        constraints: implementation-specific
- prompting_technique: prompt11
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a expert in RISC-V.\n\nTask:\n\
    You will be given excerpts from RISC-V Instruction Set Manual (RISC-V ISA) and\
    \ have to extract architectural parameters from them.\nThe usage of following\
    \ words usually implies a parameter so put extra focus on them:\nmay/might/should,\n\
    optional/optionally,\nimplementation defined/implementation specific,\ncan/either\n\
    However, parameters may exist even when these words are absent.\nAlso, it is not\
    \ necessary that every excerpt will contain parameters.\n\nInstructions on how\
    \ to format the output:\nThe output should be formatted as a JSON instance that\
    \ conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\"\
    : {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\"\
    : \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe\
    \ object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\
    \ The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\
    \nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\": {\"properties\"\
    : {\"name\": {\"description\": \"Concise parameter name given in the specification\
    \ or derived from the description\", \"title\": \"Name\", \"type\": \"string\"\
    }, \"description\": {\"description\": \"Description derived strictly from the\
    \ specification explaining what behavior or capability varies due to this implementation-defined\
    \ parameter\", \"title\": \"Description\", \"type\": \"string\"}, \"type\": {\"\
    description\": \"type of values the parameter takes : integer | boolean | enum\
    \ | bitfield | range | structural\", \"title\": \"Type\", \"type\": \"string\"\
    }, \"constraints\": {\"description\": \"Explicit constraints on the values that\
    \ the parameter can take or 'unspecified'\", \"title\": \"Constraints\", \"type\"\
    : \"string\"}}, \"required\": [\"name\", \"description\", \"type\", \"constraints\"\
    ], \"title\": \"Parameter\", \"type\": \"object\"}}, \"properties\": {\"parameters\"\
    : {\"items\": {\"$ref\": \"#/$defs/Parameter\"}, \"title\": \"Parameters\", \"\
    type\": \"array\"}}, \"required\": [\"parameters\"]}\n```\n\nRules:\n- NEVER describe\
    \ the schema.\n- If constraint refers to external source NEVER WRITE IT; INSTEAD\
    \ WRITE unspecified.\n- Output ONLY data.\n\nReasoning Process (Think Step-by-Step):\n\
    1. Is this a fixed rule or address mapping set by the ISA? Even if it is called\
    \ a 'convention', if it must be followed for standard compliance, DISCARD it.\n\
    2. Is this a field labeled WARL (Write Any values, Reads Legal values)? If yes,\
    \ it is ALWAYS a parameter for legal values and mapping behavior.\n3. Does the\
    \ text allow for different 'BEHAVIOUR' or 'VALUES' across different chips? If\
    \ the hardware designer has a choice between A or B, EXTRACT it.\n4. Once a choice\
    \ is extracted, check if the spec specifies a type or constraint on its values.\n\
    \nExamples:\n- Text: 'By convention, the red light is always located at the top\
    \ of the traffic signal and indicates that the vehicle must stop.'\n  Reasoning:\
    \ This is a fixed standard ('By convention') required for the system to work.\
    \ A manufacturer cannot choose to put the red light at the bottom and remain compliant.\n\
    \  Result: 'parameters: []'\n  (This is a negative example: showing what NOT to\
    \ extract).\n\n- Text: 'The horsepower and fuel-tank capacity of an engine and\
    \ the material of the seats are all manufacturer-specific.'\n  Reasoning: The\
    \ phrase 'manufacturer-specific' indicates these are choices the builder makes.\
    \ Different versions of the car will have different values.\n  Output:\n  - name:\
    \ engine_horsepower\n    description: The power output of the engine as determined\
    \ by the manufacturer.\n    type: range\n    constraints: manufacturer-specific\n\
    \  - name: fuel_tank_capacity\n    description: The total volume of fuel the vehicle\
    \ can store.\n    type: range\n    constraints: manufacturer-specific\n  - name:\
    \ seat_material\n    description: The type of material used for the interior upholstery.\n\
    \    type: enum\n    constraints: manufacturer-specific\n  This is a positive\
    \ example.\n\nExcerpt from RISC-V (extract parameters from the following text):\n\
    Privileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according to\
    \ address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr_accessibility
        description: The read and write accessibility of CSRs according to privilege
          level.
        type: enum
        constraints: unspecified
      - name: lowest_privilege_level_access
        description: The lowest privilege level that can access the CSR.
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_accessibility_encoding
        description: The encoding method for the read and write accessibility of CSRs
          according to privilege level.
        type: enum
        constraints: unspecified
      - name: csr_privilege_level_encoding
        description: The encoding method for the lowest privilege level that can access
          the CSR.
        type: enum
        constraints: unspecified
- prompting_technique: prompt12
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\" which contains the list of parameters. \n- Example format:\
    \ {'parameters': [{...}, {...}]}\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nPrivileged Spec 19.3.1:\nCaches organize copies of data into cache blocks,\
    \ each of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity and organization of a cache are implementation-specific.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific.
        type: integer
        constraints: shall be uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parse_error: true
      error: "Invalid json output: {'parameters': [\n  {'name': 'cache_block_size',\
        \ \n   'description': 'size of a cache block', \n   'type': 'range', \n  \
        \ 'constraints': 'unspecified'},\n  {'name': 'cache_capacity', \n   'description':\
        \ 'capacity of a cache', \n   'type': 'range', \n   'constraints': 'unspecified'},\n\
        \  {'name': 'cache_organization', \n   'description': 'organization of a cache',\
        \ \n   'type': 'enum', \n   'constraints': 'unspecified'}\n]}\nFor troubleshooting,\
        \ visit: https://docs.langchain.com/oss/python/langchain/errors/OUTPUT_PARSING_FAILURE "
      raw_output: "{'parameters': [\n  {'name': 'cache_block_size', \n   'description':\
        \ 'size of a cache block', \n   'type': 'range', \n   'constraints': 'unspecified'},\n\
        \  {'name': 'cache_capacity', \n   'description': 'capacity of a cache', \n\
        \   'type': 'range', \n   'constraints': 'unspecified'},\n  {'name': 'cache_organization',\
        \ \n   'description': 'organization of a cache', \n   'type': 'enum', \n \
        \  'constraints': 'unspecified'}\n]}"
- prompting_technique: prompt12
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\" which contains the list of parameters. \n- Example format:\
    \ {'parameters': [{...}, {...}]}\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nPrivileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according\
    \ to address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: CSR Accessibility Encoding
        description: The upper 4 bits (csr[11:8]) of the CSR address encode the read
          and write accessibility of the CSRs according to privilege level.
        type: bitfield
        constraints: unspecified
      - name: Read/Write Indicator
        description: The top two bits (csr[11:10]) indicate whether the register is
          read/write (00, 01, or 10) or read-only (11).
        type: enum
        constraints: unspecified
      - name: Minimum Privilege Level Access
        description: The next two bits (csr[9:8]) encode the lowest privilege level
          that can access the CSR.
        type: bitfield
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parse_error: true
      error: 'Invalid json output: {''parameters'': []}

        For troubleshooting, visit: https://docs.langchain.com/oss/python/langchain/errors/OUTPUT_PARSING_FAILURE '
      raw_output: '{''parameters'': []}'
- prompting_technique: prompt12
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. 'see section 4.2'), NEVER WRITE IT; instead\
    \ write 'unspecified'.\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named 'parameters' which contains the list of parameters. \n\n\nReasoning Process\
    \ (Follow this strictly Step-by-Step):\n1. FILTER: Is this a fixed rule, standard,\
    \ or address mapping set by the ISA? If it MUST be followed for compliance, DISCARD\
    \ it immediately.\n2. CHECK WARL: Is a field labeled WARL (Write Any values, Reads\
    \ Legal values)? If yes, this is ALWAYS a parameter. Extract it.\n3. IDENTIFY\
    \ CHOICE: Does the text allow for different 'BEHAVIOUR' or 'VALUES' across different\
    \ chips? If the hardware designer has a CHOICE (e.g., between A or B), you MUST\
    \ extract it.\n4. VALIDATE: Once a choice is extracted, check if the spec specifies\
    \ a type or constraint on its values.\n\nExcerpt from RISC-V (extract parameters\
    \ from the following text):\nPrivileged Spec 19.3.1:\nCaches organize copies of\
    \ data into cache blocks, each of which represents a contiguous, naturally aligned\
    \ power-of-two (or NAPOT) range of memory locations. A cache block is identified\
    \ by any of the physical addresses corresponding to the underlying memory locations.\
    \ The capacity and organization of a cache and the size of a cache block are both\
    \ implementation-specific, and the execution environment provides software a means\
    \ to discover information about the caches and cache blocks in a system. In the\
    \ initial set of CMO extensions, the size of a cache block shall be uniform throughout\
    \ the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache is implementation-specific and varies
          across different chips.
        type: range
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache is implementation-specific and varies
          across different chips.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific and must
          be uniform throughout the system according to the initial set of CMO extensions.
        type: integer
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      error: '402 Client Error: Payment Required for url: https://router.huggingface.co/novita/v3/openai/chat/completions
        (Request ID: Root=1-6980e0e3-7d3efb6372ddae4d3157098f;ea358f61-3c33-4b4e-8962-d5e79f34a633)


        Credit balance is depleted: purchase pre-paid credits to continue using Inference
        Providers with your account. Alternatively, subscribe to PRO to get 20x more
        included usage.'
- prompting_technique: prompt12
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. 'see section 4.2'), NEVER WRITE IT; instead\
    \ write 'unspecified'.\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named 'parameters' which contains the list of parameters. \n\n\nReasoning Process\
    \ (Follow this strictly Step-by-Step):\n1. FILTER: Is this a fixed rule, standard,\
    \ or address mapping set by the ISA? If it MUST be followed for compliance, DISCARD\
    \ it immediately.\n2. CHECK WARL: Is a field labeled WARL (Write Any values, Reads\
    \ Legal values)? If yes, this is ALWAYS a parameter. Extract it.\n3. IDENTIFY\
    \ CHOICE: Does the text allow for different 'BEHAVIOUR' or 'VALUES' across different\
    \ chips? If the hardware designer has a CHOICE (e.g., between A or B), you MUST\
    \ extract it.\n4. VALIDATE: Once a choice is extracted, check if the spec specifies\
    \ a type or constraint on its values.\n\nExcerpt from RISC-V (extract parameters\
    \ from the following text):\nPrivileged Spec 2.1:\n\"Conventional\" R/W accessibility\
    \ of CSRs according to address mapping\nThe standard RISC-V ISA sets aside a 12-bit\
    \ encoding space (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4\
    \ bits of the CSR address (csr[11:8]) are used to encode the read and write accessibility\
    \ of the CSRs according to privilege level as shown in Table 1. The top two bits\
    \ (csr[11:10]) indicate whether the register is read/write (00,01, or 10) or read-only\
    \ (11). The next two bits (csr[9:8]) encode the lowest privilege level that can\
    \ access the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      error: '402 Client Error: Payment Required for url: https://router.huggingface.co/featherless-ai/v1/chat/completions
        (Request ID: Root=1-6980e0e4-674ba6762e3637962dbcf223;47041aa7-e7b5-4a3c-a7b4-d84a1a6bc42f)


        Credit balance is depleted: purchase pre-paid credits to continue using Inference
        Providers with your account. Alternatively, subscribe to PRO to get 20x more
        included usage.'
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      error: '402 Client Error: Payment Required for url: https://router.huggingface.co/novita/v3/openai/chat/completions
        (Request ID: Root=1-6980e0e4-5766ec853ee72e7a190d81cc;86add5ea-a0d5-480b-a084-9c3a26db243e)


        Credit balance is depleted: purchase pre-paid credits to continue using Inference
        Providers with your account. Alternatively, subscribe to PRO to get 20x more
        included usage.'
- prompting_technique: prompt12
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. 'see section 4.2'), NEVER WRITE IT; instead\
    \ write 'unspecified'.\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named 'parameters' which contains the list of parameters. \n\n\nReasoning Process\
    \ (Follow this strictly Step-by-Step):\n1. FILTER: Is this a fixed rule, standard,\
    \ or address mapping set by the ISA? If it MUST be followed for compliance, DISCARD\
    \ it immediately.\n2. CHECK WARL: Is a field labeled WARL (Write Any values, Reads\
    \ Legal values)? If yes, this is ALWAYS a parameter. Extract it.\n3. IDENTIFY\
    \ CHOICE: Does the text allow for different 'BEHAVIOUR' or 'VALUES' across different\
    \ chips? If the hardware designer has a CHOICE (e.g., between A or B), you MUST\
    \ extract it.\n4. VALIDATE: Once a choice is extracted, check if the spec specifies\
    \ a type or constraint on its values.\n\nExcerpt from RISC-V (extract parameters\
    \ from the following text):\nPrivileged Spec 19.3.1:\nCaches organize copies of\
    \ data into cache blocks, each of which represents a contiguous, naturally aligned\
    \ power-of-two (or NAPOT) range of memory locations. A cache block is identified\
    \ by any of the physical addresses corresponding to the underlying memory locations.\
    \ The capacity and organization of a cache and the size of a cache block are both\
    \ implementation-specific, and the execution environment provides software a means\
    \ to discover information about the caches and cache blocks in a system. In the\
    \ initial set of CMO extensions, the size of a cache block shall be uniform throughout\
    \ the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The capacity of a cache is implementation-specific and can vary.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache is implementation-specific and can
          vary.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block is implementation-specific, but it
          must be uniform throughout the system according to the initial set of CMO
          extensions.
        type: integer
        constraints: uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: Cache block size
        type: range
        constraints: unspecified
      - name: cache_capacity
        description: Cache capacity
        type: range
        constraints: unspecified
      - name: cache_block_organization
        description: Cache block organization
        type: enum
        constraints: unspecified
- prompting_technique: prompt12
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. 'see section 4.2'), NEVER WRITE IT; instead\
    \ write 'unspecified'.\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named 'parameters' which contains the list of parameters. \n\n\nReasoning Process\
    \ (Follow this strictly Step-by-Step):\n1. FILTER: Is this a fixed rule, standard,\
    \ or address mapping set by the ISA? If it MUST be followed for compliance, DISCARD\
    \ it immediately.\n2. CHECK WARL: Is a field labeled WARL (Write Any values, Reads\
    \ Legal values)? If yes, this is ALWAYS a parameter. Extract it.\n3. IDENTIFY\
    \ CHOICE: Does the text allow for different 'BEHAVIOUR' or 'VALUES' across different\
    \ chips? If the hardware designer has a CHOICE (e.g., between A or B), you MUST\
    \ extract it.\n4. VALIDATE: Once a choice is extracted, check if the spec specifies\
    \ a type or constraint on its values.\n\nExcerpt from RISC-V (extract parameters\
    \ from the following text):\nPrivileged Spec 2.1:\n\"Conventional\" R/W accessibility\
    \ of CSRs according to address mapping\nThe standard RISC-V ISA sets aside a 12-bit\
    \ encoding space (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4\
    \ bits of the CSR address (csr[11:8]) are used to encode the read and write accessibility\
    \ of the CSRs according to privilege level as shown in Table 1. The top two bits\
    \ (csr[11:10]) indicate whether the register is read/write (00,01, or 10) or read-only\
    \ (11). The next two bits (csr[9:8]) encode the lowest privilege level that can\
    \ access the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: csr[11:10]
        description: Indicates whether the register is read/write (00,01, or 10) or
          read-only (11)
        type: enum
        constraints: unspecified
      - name: csr[9:8]
        description: Encodes the lowest privilege level that can access the CSR
        type: enum
        constraints: unspecified
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters: []
- prompting_technique: prompt13
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The misa register\
    \ is a WARL register. By convention, the lower 26 bits are used to indicate the\
    \ presence of standard extensions A through Z.'\n  Reasoning: While it mentions\
    \ WARL, the specific mapping of bits to extensions is a fixed 'convention' required\
    \ for software compatibility. A designer cannot remap 'A' to bit 5 and remain\
    \ standard.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN parameter can be\
    \ either 32 or 64 bits. In some implementations, the upper bits [63:32] of a register\
    \ may be ignored when operating in RV32 mode.'\n  Reasoning: The word 'either'\
    \ and 'may be ignored' indicates a CHOICE. One hardware design might support 64\
    \ bits, while another only 32. \n  Output:\n  - name: mxlen_width\n    description:\
    \ The supported bit-width of the machine architecture.\n    type: enum\n    constraints:\
    \ 32, 64\n  - name: upper_bit_behavior\n    description: Behavior of bits [63:32]\
    \ when in RV32 mode.\n    type: string\n    constraints: may be ignored\n\n- Text:\
    \ 'The number of PMP (Physical Memory Protection) entries is implementation-specific,\
    \ but must be between 0 and 64. The pmpcfg0 register is a WARL field.'\n  Reasoning:\
    \ 'Implementation-specific' and 'WARL' both signal hardware choices. The designer\
    \ chooses the number of entries and the legal values for the config register.\n\
    \  Output:\n  - name: pmp_entries_count\n    description: Total number of implemented\
    \ PMP entries.\n    type: integer\n    constraints: 0-64\n  - name: pmpcfg0_legal_values\n\
    \    description: The set of supported/legal values for the WARL pmpcfg0 register.\n\
    \    type: set\n    constraints: implementation-defined\n\nExcerpt from RISC-V\
    \ (extract parameters from the following text):\nPrivileged Spec 19.3.1:\nCaches\
    \ organize copies of data into cache blocks, each of which represents a contiguous,\
    \ naturally aligned power-of-two (or NAPOT) range of memory locations. A cache\
    \ block is identified by any of the physical addresses corresponding to the underlying\
    \ memory locations. The capacity and organization of a cache and the size of a\
    \ cache block are both implementation-specific, and the execution environment\
    \ provides software a means to discover information about the caches and cache\
    \ blocks in a system. In the initial set of CMO extensions, the size of a cache\
    \ block shall be uniform throughout the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The total capacity of the cache.
        type: integer
        constraints: implementation-defined
      - name: cache_organization
        description: The organization method of the cache.
        type: string
        constraints: implementation-defined
      - name: cache_block_size
        description: The size of a cache block.
        type: integer
        constraints: uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: Size of a cache block.
        type: integer
        constraints: unspecified
      - name: cache_capacity
        description: Capacity of a cache.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: Organization of a cache.
        type: string
        constraints: implementation-defined
- prompting_technique: prompt13
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The misa register\
    \ is a WARL register. By convention, the lower 26 bits are used to indicate the\
    \ presence of standard extensions A through Z.'\n  Reasoning: While it mentions\
    \ WARL, the specific mapping of bits to extensions is a fixed 'convention' required\
    \ for software compatibility. A designer cannot remap 'A' to bit 5 and remain\
    \ standard.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN parameter can be\
    \ either 32 or 64 bits. In some implementations, the upper bits [63:32] of a register\
    \ may be ignored when operating in RV32 mode.'\n  Reasoning: The word 'either'\
    \ and 'may be ignored' indicates a CHOICE. One hardware design might support 64\
    \ bits, while another only 32. \n  Output:\n  - name: mxlen_width\n    description:\
    \ The supported bit-width of the machine architecture.\n    type: enum\n    constraints:\
    \ 32, 64\n  - name: upper_bit_behavior\n    description: Behavior of bits [63:32]\
    \ when in RV32 mode.\n    type: string\n    constraints: may be ignored\n\n- Text:\
    \ 'The number of PMP (Physical Memory Protection) entries is implementation-specific,\
    \ but must be between 0 and 64. The pmpcfg0 register is a WARL field.'\n  Reasoning:\
    \ 'Implementation-specific' and 'WARL' both signal hardware choices. The designer\
    \ chooses the number of entries and the legal values for the config register.\n\
    \  Output:\n  - name: pmp_entries_count\n    description: Total number of implemented\
    \ PMP entries.\n    type: integer\n    constraints: 0-64\n  - name: pmpcfg0_legal_values\n\
    \    description: The set of supported/legal values for the WARL pmpcfg0 register.\n\
    \    type: set\n    constraints: implementation-defined\n\nExcerpt from RISC-V\
    \ (extract parameters from the following text):\nPrivileged Spec 2.1:\n\"Conventional\"\
    \ R/W accessibility of CSRs according to address mapping\nThe standard RISC-V\
    \ ISA sets aside a 12-bit encoding space (csr[11:0]) for up to 4,096 CSRs. By\
    \ convention, the upper 4 bits of the CSR address (csr[11:8]) are used to encode\
    \ the read and write accessibility of the CSRs according to privilege level as\
    \ shown in Table 1. The top two bits (csr[11:10]) indicate whether the register\
    \ is read/write (00,01, or 10) or read-only (11). The next two bits (csr[9:8])\
    \ encode the lowest privilege level that can access the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parse_error: true
      error: "Failed to parse ParameterList from completion []. Got: 1 validation\
        \ error for ParameterList\n  Input should be a valid dictionary or instance\
        \ of ParameterList [type=model_type, input_value=[], input_type=list]\n  \
        \  For further information visit https://errors.pydantic.dev/2.12/v/model_type\n\
        For troubleshooting, visit: https://docs.langchain.com/oss/python/langchain/errors/OUTPUT_PARSING_FAILURE "
      raw_output: '```json

        []

        ```'
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_encoding
        description: 12-bit encoding space for up to 4,096 CSRs.
        type: string
        constraints: unspecified
      - name: csr_accessibility_encoding
        description: Encoding for read and write accessibility of CSRs according to
          privilege level.
        type: enum
        constraints: unspecified
      - name: csr_read_only
        description: Top two bits (csr[11:10]) indicate whether the register is read-only.
        type: boolean
        constraints: unspecified
      - name: csr_lowest_privilege_level
        description: Next two bits (csr[9:8]) encode the lowest privilege level that
          can access the CSR.
        type: enum
        constraints: unspecified
- prompting_technique: prompt13
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The misa register\
    \ is a WARL register. By convention, the lower 26 bits are used to indicate the\
    \ presence of standard extensions A through Z.'\n  Reasoning: While it mentions\
    \ WARL, the specific mapping of bits to extensions is a fixed 'convention' required\
    \ for software compatibility. A designer cannot remap 'A' to bit 5 and remain\
    \ standard.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN parameter can be\
    \ either 32 or 64 bits. In some implementations, the upper bits [63:32] of a register\
    \ may be ignored when operating in RV32 mode.'\n  Reasoning: The word 'either'\
    \ and 'may be ignored' indicates a CHOICE. One hardware design might support 64\
    \ bits, while another only 32. \n  Output:\n  - name: mxlen_width\n    description:\
    \ The supported bit-width of the machine architecture.\n    type: enum\n    constraints:\
    \ 32, 64\n  - name: upper_bit_behavior\n    description: Behavior of bits [63:32]\
    \ when in RV32 mode.\n    type: string\n    constraints: may be ignored\n\n- Text:\
    \ 'The number of PMP (Physical Memory Protection) entries is implementation-specific,\
    \ but must be between 0 and 64. The pmpcfg0 register is a WARL field.'\n  Reasoning:\
    \ 'Implementation-specific' and 'WARL' both signal hardware choices. The designer\
    \ chooses the number of entries and the legal values for the config register.\n\
    \  Output:\n  - name: pmp_entries_count\n    description: Total number of implemented\
    \ PMP entries.\n    type: integer\n    constraints: 0-64\n  - name: pmpcfg0_legal_values\n\
    \    description: The set of supported/legal values for the WARL pmpcfg0 register.\n\
    \    type: set\n    constraints: implementation-defined\n\nExcerpt from RISC-V\
    \ (extract parameters from the following text):\nPrivileged Spec 19.3.1:\nCaches\
    \ organize copies of data into cache blocks, each of which represents a contiguous,\
    \ naturally aligned power-of-two (or NAPOT) range of memory locations. A cache\
    \ block is identified by any of the physical addresses corresponding to the underlying\
    \ memory locations. The capacity and organization of a cache and the size of a\
    \ cache block are both implementation-specific, and the execution environment\
    \ provides software a means to discover information about the caches and cache\
    \ blocks in a system. In the initial set of CMO extensions, the size of a cache\
    \ block shall be uniform throughout the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: Total capacity of the cache.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: Organization structure of the cache.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: Size of a cache block.
        type: integer
        constraints: uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parse_error: true
      error: "Failed to parse ParameterList from completion \"parameters\". Got: 1\
        \ validation error for ParameterList\n  Input should be a valid dictionary\
        \ or instance of ParameterList [type=model_type, input_value='parameters',\
        \ input_type=str]\n    For further information visit https://errors.pydantic.dev/2.12/v/model_type\n\
        For troubleshooting, visit: https://docs.langchain.com/oss/python/langchain/errors/OUTPUT_PARSING_FAILURE "
      raw_output: "\"parameters\": [\n  {\n    \"name\": \"cache_block_size\",\n \
        \   \"description\": \"The size of a cache block.\",\n    \"type\": \"integer\"\
        ,\n    \"constraints\": \"unspecified\"\n  },\n  {\n    \"name\": \"cache_capacity\"\
        ,\n    \"description\": \"The capacity of a cache.\",\n    \"type\": \"integer\"\
        ,\n    \"constraints\": \"unspecified\"\n  },\n  {\n    \"name\": \"cache_organisation\"\
        ,\n    \"description\": \"The organization of a cache.\",\n    \"type\": \"\
        string\",\n    \"constraints\": \"unspecified\"\n  }\n]"
- prompting_technique: prompt13
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The misa register\
    \ is a WARL register. By convention, the lower 26 bits are used to indicate the\
    \ presence of standard extensions A through Z.'\n  Reasoning: While it mentions\
    \ WARL, the specific mapping of bits to extensions is a fixed 'convention' required\
    \ for software compatibility. A designer cannot remap 'A' to bit 5 and remain\
    \ standard.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN parameter can be\
    \ either 32 or 64 bits. In some implementations, the upper bits [63:32] of a register\
    \ may be ignored when operating in RV32 mode.'\n  Reasoning: The word 'either'\
    \ and 'may be ignored' indicates a CHOICE. One hardware design might support 64\
    \ bits, while another only 32. \n  Output:\n  - name: mxlen_width\n    description:\
    \ The supported bit-width of the machine architecture.\n    type: enum\n    constraints:\
    \ 32, 64\n  - name: upper_bit_behavior\n    description: Behavior of bits [63:32]\
    \ when in RV32 mode.\n    type: string\n    constraints: may be ignored\n\n- Text:\
    \ 'The number of PMP (Physical Memory Protection) entries is implementation-specific,\
    \ but must be between 0 and 64. The pmpcfg0 register is a WARL field.'\n  Reasoning:\
    \ 'Implementation-specific' and 'WARL' both signal hardware choices. The designer\
    \ chooses the number of entries and the legal values for the config register.\n\
    \  Output:\n  - name: pmp_entries_count\n    description: Total number of implemented\
    \ PMP entries.\n    type: integer\n    constraints: 0-64\n  - name: pmpcfg0_legal_values\n\
    \    description: The set of supported/legal values for the WARL pmpcfg0 register.\n\
    \    type: set\n    constraints: implementation-defined\n\nExcerpt from RISC-V\
    \ (extract parameters from the following text):\nPrivileged Spec 2.1:\n\"Conventional\"\
    \ R/W accessibility of CSRs according to address mapping\nThe standard RISC-V\
    \ ISA sets aside a 12-bit encoding space (csr[11:0]) for up to 4,096 CSRs. By\
    \ convention, the upper 4 bits of the CSR address (csr[11:8]) are used to encode\
    \ the read and write accessibility of the CSRs according to privilege level as\
    \ shown in Table 1. The top two bits (csr[11:10]) indicate whether the register\
    \ is read/write (00,01, or 10) or read-only (11). The next two bits (csr[9:8])\
    \ encode the lowest privilege level that can access the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters: []
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: csr_encoding
        description: Encoding of the 12-bit CSR address space.
        type: enum
        constraints: unspecified
      - name: csr_read_write
        description: The top two bits (csr[11:10]) indicate whether the register is
          read/write (00,01, or 10) or read-only (11).
        type: enum
        constraints: 00, 01, 10, 11
      - name: csr_privilege_level
        description: The next two bits (csr[9:8]) encode the lowest privilege level
          that can access the CSR.
        type: enum
        constraints: unspecified
- prompting_technique: prompt14
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32. \n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nPrivileged Spec 19.3.1:\nCaches organize copies of data into cache blocks,\
    \ each of which represents a contiguous, naturally aligned power-of-two (or NAPOT)\
    \ range of memory locations. A cache block is identified by any of the physical\
    \ addresses corresponding to the underlying memory locations. The capacity and\
    \ organization of a cache and the size of a cache block are both implementation-specific,\
    \ and the execution environment provides software a means to discover information\
    \ about the caches and cache blocks in a system. In the initial set of CMO extensions,\
    \ the size of a cache block shall be uniform throughout the system.\n"
  input:
    text: 'Privileged Spec 19.3.1:

      Caches organize copies of data into cache blocks, each of which represents a
      contiguous, naturally aligned power-of-two (or NAPOT) range of memory locations.
      A cache block is identified by any of the physical addresses corresponding to
      the underlying memory locations. The capacity and organization of a cache and
      the size of a cache block are both implementation-specific, and the execution
      environment provides software a means to discover information about the caches
      and cache blocks in a system. In the initial set of CMO extensions, the size
      of a cache block shall be uniform throughout the system.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters:
      - name: cache_capacity
        description: The total capacity of the cache.
        type: integer
        constraints: unspecified
      - name: cache_organization
        description: The organization structure of the cache.
        type: structural
        constraints: unspecified
      - name: cache_block_size
        description: The size of a cache block.
        type: integer
        constraints: uniform throughout the system
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters:
      - name: cache_block_size
        description: The size of a cache block.
        type: implementation specific
        constraints: unspecified
      - name: cache_capacity
        description: The capacity of a cache.
        type: implementation specific
        constraints: unspecified
      - name: cache_organization
        description: The organization of a cache.
        type: implementation specific
        constraints: unspecified
- prompting_technique: prompt14
  prompt: "\nRISC-V is an Open Standard Instruction Set Architecture (ISA).\nTo put\
    \ it simply, an ISA is the language that a computer's hardware speaks. It defines\
    \ the set of instructions (like add, subtract, load, or store) that a processor\
    \ can execute.\nArchitectural Parameters are the variables of a hardware design.\
    \ They are the specific values or behaviors that the hardware designer must decide\
    \ on and the software must account for.\nIn the most basic form, a parameter is\
    \ a choice between say A or B as value of a field which changes the behaviour\
    \ of processor.\nIf it is a standard or convention that we have to follow it giving\
    \ us no choice it is not a parameter.\nYou are a strict, pedantic expert in RISC-V.\n\
    \nTask:\nYou will be given excerpts from the RISC-V Instruction Set Manual (RISC-V\
    \ ISA). You MUST extract architectural parameters from them.\nYou are required\
    \ to AGGRESSIVELY focus on the following trigger words, as they usually imply\
    \ a parameter:\nmay/might/should,\noptional/optionally,\nimplementation defined/implementation\
    \ specific,\ncan/either\nHowever, parameters may exist even when these words are\
    \ absent.\nIf an excerpt contains no parameters, return an empty list.\n\nInstructions\
    \ on how to format the output:\nThe output should be formatted as a JSON instance\
    \ that conforms to the JSON schema below.\n\nAs an example, for the schema {\"\
    properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\"\
    , \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"\
    foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance\
    \ of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is\
    \ not well-formatted.\n\nHere is the output schema:\n```\n{\"$defs\": {\"Parameter\"\
    : {\"properties\": {\"name\": {\"description\": \"Concise parameter name given\
    \ in the specification or derived from the description\", \"title\": \"Name\"\
    , \"type\": \"string\"}, \"description\": {\"description\": \"Description derived\
    \ strictly from the specification explaining what behavior or capability varies\
    \ due to this implementation-defined parameter\", \"title\": \"Description\",\
    \ \"type\": \"string\"}, \"type\": {\"description\": \"type of values the parameter\
    \ takes : integer | boolean | enum | bitfield | range | structural\", \"title\"\
    : \"Type\", \"type\": \"string\"}, \"constraints\": {\"description\": \"Explicit\
    \ constraints on the values that the parameter can take or 'unspecified'\", \"\
    title\": \"Constraints\", \"type\": \"string\"}}, \"required\": [\"name\", \"\
    description\", \"type\", \"constraints\"], \"title\": \"Parameter\", \"type\"\
    : \"object\"}}, \"properties\": {\"parameters\": {\"items\": {\"$ref\": \"#/$defs/Parameter\"\
    }, \"title\": \"Parameters\", \"type\": \"array\"}}, \"required\": [\"parameters\"\
    ]}\n```\n\nStrict Rules:\n- NEVER output the schema definition.\n- If a constraint\
    \ refers to an external source (e.g. \"see section 4.2\"), NEVER WRITE IT; instead\
    \ write \"unspecified\".\n- Output ONLY the requested data.\n- Do not add conversational\
    \ text or explanations.\n- The output MUST be a JSON object with a single key\
    \ named \"parameters\".\n\nReasoning Process (Follow this strictly Step-by-Step):\n\
    1. FILTER: Is this a fixed rule, standard, or address mapping set by the ISA?\
    \ If it MUST be followed for compliance, DISCARD it immediately.\n2. CHECK WARL:\
    \ Is a field labeled WARL (Write Any values, Reads Legal values)? If yes, this\
    \ is ALWAYS a parameter. Extract it.\n3. IDENTIFY CHOICE: Does the text allow\
    \ for different 'BEHAVIOUR' or 'VALUES' across different chips? If the hardware\
    \ designer has a CHOICE (e.g., between A or B), you MUST extract it.\n4. VALIDATE:\
    \ Once a choice is extracted, check if the spec specifies a type or constraint\
    \ on its values.\n\nExamples:\n\n- Text: 'The funct3 field of the ADDI instruction\
    \ is always bits [14:12] and must be set to 000. Any other value is reserved.'\n\
    \  Reasoning: These bits are fixed by the ISA to define the opcode. A hardware\
    \ designer cannot change which bits represent funct3 or what value they hold for\
    \ ADDI. There is NO choice.\n  Result: 'parameters: []'\n\n- Text: 'The MXLEN\
    \ parameter can be either 32 or 64 bits. In some implementations, the upper bits\
    \ [63:32] of a register may be ignored when operating in RV32 mode.'\n  Reasoning:\
    \ The word 'either' and 'may be ignored' indicates a CHOICE. One hardware design\
    \ might support 64 bits, while another only 32. \n  Output:\n  - name: mxlen_width\n\
    \    description: The supported bit-width of the machine architecture.\n    type:\
    \ enum\n    constraints: 32, 64\n  - name: upper_bit_behavior\n    description:\
    \ Behavior of bits [63:32] when in RV32 mode.\n    type: string\n    constraints:\
    \ may be ignored\n\nExcerpt from RISC-V (extract parameters from the following\
    \ text):\nPrivileged Spec 2.1:\n\"Conventional\" R/W accessibility of CSRs according\
    \ to address mapping\nThe standard RISC-V ISA sets aside a 12-bit encoding space\
    \ (csr[11:0]) for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR\
    \ address (csr[11:8]) are used to encode the read and write accessibility of the\
    \ CSRs according to privilege level as shown in Table 1. The top two bits (csr[11:10])\
    \ indicate whether the register is read/write (00,01, or 10) or read-only (11).\
    \ The next two bits (csr[9:8]) encode the lowest privilege level that can access\
    \ the CSR.\n"
  input:
    text: 'Privileged Spec 2.1:

      "Conventional" R/W accessibility of CSRs according to address mapping

      The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up
      to 4,096 CSRs. By convention, the upper 4 bits of the CSR address (csr[11:8])
      are used to encode the read and write accessibility of the CSRs according to
      privilege level as shown in Table 1. The top two bits (csr[11:10]) indicate
      whether the register is read/write (00,01, or 10) or read-only (11). The next
      two bits (csr[9:8]) encode the lowest privilege level that can access the CSR.'
  models:
  - model_name: Qwen/Qwen2.5-14B-Instruct
    output:
      parameters: []
  - model_name: meta-llama/Llama-3.1-8B-Instruct
    output:
      parameters: []
